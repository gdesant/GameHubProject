{"id":"../../node_modules/@colyseus/schema/lib/Schema.js","dependencies":[{"name":"C:\\Users\\S de Santi\\Desktop\\NewProject\\package.json","includedInParent":true,"mtime":1624667712346},{"name":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\package.json","includedInParent":true,"mtime":1624667516256},{"name":"./spec","loc":{"line":33,"column":21},"parent":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\Schema.js","resolved":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\spec.js"},{"name":"./annotations","loc":{"line":34,"column":28},"parent":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\Schema.js","resolved":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\annotations.js"},{"name":"./encoding/encode","loc":{"line":35,"column":21},"parent":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\Schema.js","resolved":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\encoding\\encode.js"},{"name":"./encoding/decode","loc":{"line":36,"column":21},"parent":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\Schema.js","resolved":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\encoding\\decode.js"},{"name":"./types/ArraySchema","loc":{"line":37,"column":28},"parent":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\Schema.js","resolved":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\types\\ArraySchema.js"},{"name":"./types/MapSchema","loc":{"line":38,"column":26},"parent":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\Schema.js","resolved":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\types\\MapSchema.js"},{"name":"./types/CollectionSchema","loc":{"line":39,"column":33},"parent":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\Schema.js","resolved":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\types\\CollectionSchema.js"},{"name":"./types/SetSchema","loc":{"line":40,"column":26},"parent":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\Schema.js","resolved":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\types\\SetSchema.js"},{"name":"./changes/ChangeTree","loc":{"line":41,"column":27},"parent":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\Schema.js","resolved":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\changes\\ChangeTree.js"},{"name":"./events/EventEmitter","loc":{"line":42,"column":29},"parent":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\Schema.js","resolved":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\events\\EventEmitter.js"},{"name":"./filters","loc":{"line":43,"column":24},"parent":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\Schema.js","resolved":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\filters\\index.js"},{"name":"./types","loc":{"line":44,"column":22},"parent":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\Schema.js","resolved":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\types\\index.js"}],"generated":{"js":"\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Schema = void 0;\nvar spec_1 = require(\"./spec\");\nvar annotations_1 = require(\"./annotations\");\nvar encode = require(\"./encoding/encode\");\nvar decode = require(\"./encoding/decode\");\nvar ArraySchema_1 = require(\"./types/ArraySchema\");\nvar MapSchema_1 = require(\"./types/MapSchema\");\nvar CollectionSchema_1 = require(\"./types/CollectionSchema\");\nvar SetSchema_1 = require(\"./types/SetSchema\");\nvar ChangeTree_1 = require(\"./changes/ChangeTree\");\nvar EventEmitter_1 = require(\"./events/EventEmitter\");\nvar filters_1 = require(\"./filters\");\nvar types_1 = require(\"./types\");\nvar EncodeSchemaError = /** @class */ (function (_super) {\n    __extends(EncodeSchemaError, _super);\n    function EncodeSchemaError() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return EncodeSchemaError;\n}(Error));\nfunction assertType(value, type, klass, field) {\n    var typeofTarget;\n    var allowNull = false;\n    switch (type) {\n        case \"number\":\n        case \"int8\":\n        case \"uint8\":\n        case \"int16\":\n        case \"uint16\":\n        case \"int32\":\n        case \"uint32\":\n        case \"int64\":\n        case \"uint64\":\n        case \"float32\":\n        case \"float64\":\n            typeofTarget = \"number\";\n            if (isNaN(value)) {\n                console.log(\"trying to encode \\\"NaN\\\" in \" + klass.constructor.name + \"#\" + field);\n            }\n            break;\n        case \"string\":\n            typeofTarget = \"string\";\n            allowNull = true;\n            break;\n        case \"boolean\":\n            // boolean is always encoded as true/false based on truthiness\n            return;\n    }\n    if (typeof (value) !== typeofTarget && (!allowNull || (allowNull && value !== null))) {\n        var foundValue = \"'\" + JSON.stringify(value) + \"'\" + ((value && value.constructor && \" (\" + value.constructor.name + \")\") || '');\n        throw new EncodeSchemaError(\"a '\" + typeofTarget + \"' was expected, but \" + foundValue + \" was provided in \" + klass.constructor.name + \"#\" + field);\n    }\n}\nfunction assertInstanceType(value, type, klass, field) {\n    if (!(value instanceof type)) {\n        throw new EncodeSchemaError(\"a '\" + type.name + \"' was expected, but '\" + value.constructor.name + \"' was provided in \" + klass.constructor.name + \"#\" + field);\n    }\n}\nfunction encodePrimitiveType(type, bytes, value, klass, field) {\n    assertType(value, type, klass, field);\n    var encodeFunc = encode[type];\n    if (encodeFunc) {\n        encodeFunc(bytes, value);\n    }\n    else {\n        throw new EncodeSchemaError(\"a '\" + type + \"' was expected, but \" + value + \" was provided in \" + klass.constructor.name + \"#\" + field);\n    }\n}\nfunction decodePrimitiveType(type, bytes, it) {\n    return decode[type](bytes, it);\n}\n/**\n * Schema encoder / decoder\n */\nvar Schema = /** @class */ (function () {\n    // allow inherited classes to have a constructor\n    function Schema() {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        // fix enumerability of fields for end-user\n        Object.defineProperties(this, {\n            $changes: {\n                value: new ChangeTree_1.ChangeTree(this, undefined, new ChangeTree_1.Root()),\n                enumerable: false,\n                writable: true\n            },\n            $listeners: {\n                value: {},\n                enumerable: false,\n                writable: true\n            },\n        });\n        var descriptors = this._definition.descriptors;\n        if (descriptors) {\n            Object.defineProperties(this, descriptors);\n        }\n        //\n        // Assign initial values\n        //\n        if (args[0]) {\n            this.assign(args[0]);\n        }\n    }\n    Schema.onError = function (e) {\n        console.error(e);\n    };\n    Schema.is = function (type) {\n        return (type['_definition'] &&\n            type['_definition'].schema !== undefined);\n    };\n    Schema.prototype.assign = function (props) {\n        Object.assign(this, props);\n        return this;\n    };\n    Object.defineProperty(Schema.prototype, \"_definition\", {\n        get: function () { return this.constructor._definition; },\n        enumerable: false,\n        configurable: true\n    });\n    Schema.prototype.listen = function (attr, callback) {\n        var _this = this;\n        if (!this.$listeners[attr]) {\n            this.$listeners[attr] = new EventEmitter_1.EventEmitter();\n        }\n        this.$listeners[attr].register(callback);\n        // return un-register callback.\n        return function () {\n            return _this.$listeners[attr].remove(callback);\n        };\n    };\n    Schema.prototype.decode = function (bytes, it, ref, allChanges) {\n        if (it === void 0) { it = { offset: 0 }; }\n        if (ref === void 0) { ref = this; }\n        if (allChanges === void 0) { allChanges = new Map(); }\n        var $root = this.$changes.root;\n        var totalBytes = bytes.length;\n        var refId = 0;\n        var changes = [];\n        $root.refs.set(refId, this);\n        allChanges.set(refId, changes);\n        while (it.offset < totalBytes) {\n            var byte = bytes[it.offset++];\n            if (byte == spec_1.SWITCH_TO_STRUCTURE) {\n                refId = decode.number(bytes, it);\n                var nextRef = $root.refs.get(refId);\n                //\n                // Trying to access a reference that haven't been decoded yet.\n                //\n                if (!nextRef) {\n                    throw new Error(\"\\\"refId\\\" not found: \" + refId);\n                }\n                ref = nextRef;\n                // create empty list of changes for this refId.\n                changes = [];\n                allChanges.set(refId, changes);\n                continue;\n            }\n            var changeTree = ref['$changes'];\n            var isSchema = (ref['_definition'] !== undefined);\n            var operation = (isSchema)\n                ? (byte >> 6) << 6 // \"compressed\" index + operation\n                : byte; // \"uncompressed\" index + operation (array/map items)\n            if (operation === spec_1.OPERATION.CLEAR) {\n                //\n                // TODO: refactor me!\n                // The `.clear()` method is calling `$root.removeRef(refId)` for\n                // each item inside this collection\n                //\n                ref.clear(true);\n                continue;\n            }\n            var fieldIndex = (isSchema)\n                ? byte % (operation || 255) // if \"REPLACE\" operation (0), use 255\n                : decode.number(bytes, it);\n            var fieldName = (isSchema)\n                ? (ref['_definition'].fieldsByIndex[fieldIndex])\n                : \"\";\n            var type = changeTree.getType(fieldIndex);\n            var value = void 0;\n            var previousValue = void 0;\n            var dynamicIndex = void 0;\n            if (!isSchema) {\n                previousValue = ref['getByIndex'](fieldIndex);\n                if ((operation & spec_1.OPERATION.ADD) === spec_1.OPERATION.ADD) { // ADD or DELETE_AND_ADD\n                    dynamicIndex = (ref instanceof MapSchema_1.MapSchema)\n                        ? decode.string(bytes, it)\n                        : fieldIndex;\n                    ref['setIndex'](fieldIndex, dynamicIndex);\n                }\n                else {\n                    // here\n                    dynamicIndex = ref['getIndex'](fieldIndex);\n                }\n            }\n            else {\n                previousValue = ref[\"_\" + fieldName];\n            }\n            //\n            // Delete operations\n            //\n            if ((operation & spec_1.OPERATION.DELETE) === spec_1.OPERATION.DELETE) {\n                if (operation !== spec_1.OPERATION.DELETE_AND_ADD) {\n                    ref['deleteByIndex'](fieldIndex);\n                }\n                // Flag `refId` for garbage collection.\n                if (previousValue && previousValue['$changes']) {\n                    $root.removeRef(previousValue['$changes'].refId);\n                }\n                value = null;\n            }\n            if (fieldName === undefined) {\n                console.warn(\"@colyseus/schema: definition mismatch\");\n                //\n                // keep skipping next bytes until reaches a known structure\n                // by local decoder.\n                //\n                var nextIterator = { offset: it.offset };\n                while (it.offset < totalBytes) {\n                    if (decode.switchStructureCheck(bytes, it)) {\n                        nextIterator.offset = it.offset + 1;\n                        if ($root.refs.has(decode.number(bytes, nextIterator))) {\n                            break;\n                        }\n                    }\n                    it.offset++;\n                }\n                continue;\n            }\n            else if (operation === spec_1.OPERATION.DELETE) {\n                //\n                // FIXME: refactor me.\n                // Don't do anything.\n                //\n            }\n            else if (Schema.is(type)) {\n                var refId_1 = decode.number(bytes, it);\n                value = $root.refs.get(refId_1);\n                if (operation !== spec_1.OPERATION.REPLACE) {\n                    var childType = this.getSchemaType(bytes, it, type);\n                    if (!value) {\n                        value = this.createTypeInstance(childType);\n                        value.$changes.refId = refId_1;\n                        if (previousValue) {\n                            value.onChange = previousValue.onChange;\n                            value.onRemove = previousValue.onRemove;\n                            value.$listeners = previousValue.$listeners;\n                            if (previousValue['$changes'].refId &&\n                                refId_1 !== previousValue['$changes'].refId) {\n                                $root.removeRef(previousValue['$changes'].refId);\n                            }\n                        }\n                    }\n                    $root.addRef(refId_1, value, (value !== previousValue));\n                }\n            }\n            else if (typeof (type) === \"string\") {\n                //\n                // primitive value (number, string, boolean, etc)\n                //\n                value = decodePrimitiveType(type, bytes, it);\n            }\n            else {\n                var typeDef = types_1.getType(Object.keys(type)[0]);\n                var refId_2 = decode.number(bytes, it);\n                var valueRef = ($root.refs.has(refId_2))\n                    ? previousValue || $root.refs.get(refId_2)\n                    : new typeDef.constructor();\n                value = valueRef.clone(true);\n                value.$changes.refId = refId_2;\n                // preserve schema callbacks\n                if (previousValue) {\n                    value.onAdd = previousValue.onAdd;\n                    value.onRemove = previousValue.onRemove;\n                    value.onChange = previousValue.onChange;\n                    if (previousValue['$changes'].refId &&\n                        refId_2 !== previousValue['$changes'].refId) {\n                        $root.removeRef(previousValue['$changes'].refId);\n                        //\n                        // Trigger onRemove if structure has been replaced.\n                        //\n                        var deletes = [];\n                        var entries = previousValue.entries();\n                        var iter = void 0;\n                        while ((iter = entries.next()) && !iter.done) {\n                            var _a = __read(iter.value, 2), key = _a[0], value_1 = _a[1];\n                            deletes.push({\n                                op: spec_1.OPERATION.DELETE,\n                                field: key,\n                                value: undefined,\n                                previousValue: value_1,\n                            });\n                        }\n                        allChanges.set(previousValue['$changes'].refId, deletes);\n                    }\n                }\n                $root.addRef(refId_2, value, (valueRef !== previousValue));\n                //\n                // TODO: deprecate proxies on next version.\n                // get proxy to target value.\n                //\n                if (typeDef.getProxy) {\n                    value = typeDef.getProxy(value);\n                }\n            }\n            var hasChange = (previousValue !== value);\n            if (value !== null &&\n                value !== undefined) {\n                if (value['$changes']) {\n                    value['$changes'].setParent(changeTree.ref, changeTree.root, fieldIndex);\n                }\n                if (ref instanceof Schema) {\n                    ref[fieldName] = value;\n                    //\n                    // FIXME: use `_field` instead of `field`.\n                    //\n                    // `field` is going to use the setter of the PropertyDescriptor\n                    // and create a proxy for array/map. This is only useful for\n                    // backwards-compatibility with @colyseus/schema@0.5.x\n                    //\n                    // // ref[_field] = value;\n                }\n                else if (ref instanceof MapSchema_1.MapSchema) {\n                    // const key = ref['$indexes'].get(field);\n                    var key = dynamicIndex;\n                    // ref.set(key, value);\n                    ref['$items'].set(key, value);\n                }\n                else if (ref instanceof ArraySchema_1.ArraySchema) {\n                    // const key = ref['$indexes'][field];\n                    // console.log(\"SETTING FOR ArraySchema =>\", { field, key, value });\n                    // ref[key] = value;\n                    ref.setAt(fieldIndex, value);\n                }\n                else if (ref instanceof CollectionSchema_1.CollectionSchema ||\n                    ref instanceof SetSchema_1.SetSchema) {\n                    var index = ref.add(value);\n                    ref['setIndex'](fieldIndex, index);\n                }\n            }\n            if (hasChange\n            // &&\n            // (\n            //     this.onChange || ref.$listeners[field]\n            // )\n            ) {\n                changes.push({\n                    op: operation,\n                    field: fieldName,\n                    dynamicIndex: dynamicIndex,\n                    value: value,\n                    previousValue: previousValue,\n                });\n            }\n        }\n        this._triggerChanges(allChanges);\n        // drop references of unused schemas\n        $root.garbageCollectDeletedRefs();\n        return allChanges;\n    };\n    Schema.prototype.encode = function (encodeAll, bytes, useFilters) {\n        if (encodeAll === void 0) { encodeAll = false; }\n        if (bytes === void 0) { bytes = []; }\n        if (useFilters === void 0) { useFilters = false; }\n        var rootChangeTree = this.$changes;\n        var refIdsVisited = new WeakSet();\n        var changeTrees = [rootChangeTree];\n        var numChangeTrees = 1;\n        for (var i = 0; i < numChangeTrees; i++) {\n            var changeTree = changeTrees[i];\n            var ref = changeTree.ref;\n            var isSchema = (ref instanceof Schema);\n            // Generate unique refId for the ChangeTree.\n            changeTree.ensureRefId();\n            // mark this ChangeTree as visited.\n            refIdsVisited.add(changeTree);\n            // root `refId` is skipped.\n            if (changeTree !== rootChangeTree &&\n                (changeTree.changed || encodeAll)) {\n                encode.uint8(bytes, spec_1.SWITCH_TO_STRUCTURE);\n                encode.number(bytes, changeTree.refId);\n            }\n            var changes = (encodeAll)\n                ? Array.from(changeTree.allChanges)\n                : Array.from(changeTree.changes.values());\n            for (var j = 0, cl = changes.length; j < cl; j++) {\n                var operation = (encodeAll)\n                    ? { op: spec_1.OPERATION.ADD, index: changes[j] }\n                    : changes[j];\n                var fieldIndex = operation.index;\n                var field = (isSchema)\n                    ? ref['_definition'].fieldsByIndex && ref['_definition'].fieldsByIndex[fieldIndex]\n                    : fieldIndex;\n                // cache begin index if `useFilters`\n                var beginIndex = bytes.length;\n                // encode field index + operation\n                if (operation.op !== spec_1.OPERATION.TOUCH) {\n                    if (isSchema) {\n                        //\n                        // Compress `fieldIndex` + `operation` into a single byte.\n                        // This adds a limitaion of 64 fields per Schema structure\n                        //\n                        encode.uint8(bytes, (fieldIndex | operation.op));\n                    }\n                    else {\n                        encode.uint8(bytes, operation.op);\n                        // custom operations\n                        if (operation.op === spec_1.OPERATION.CLEAR) {\n                            continue;\n                        }\n                        // indexed operations\n                        encode.number(bytes, fieldIndex);\n                    }\n                }\n                //\n                // encode \"alias\" for dynamic fields (maps)\n                //\n                if (!isSchema &&\n                    (operation.op & spec_1.OPERATION.ADD) == spec_1.OPERATION.ADD // ADD or DELETE_AND_ADD\n                ) {\n                    if (ref instanceof MapSchema_1.MapSchema) {\n                        //\n                        // MapSchema dynamic key\n                        //\n                        var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);\n                        encode.string(bytes, dynamicIndex);\n                    }\n                }\n                if (operation.op === spec_1.OPERATION.DELETE) {\n                    //\n                    // TODO: delete from filter cache data.\n                    //\n                    // if (useFilters) {\n                    //     delete changeTree.caches[fieldIndex];\n                    // }\n                    continue;\n                }\n                // const type = changeTree.childType || ref._schema[field];\n                var type = changeTree.getType(fieldIndex);\n                // const type = changeTree.getType(fieldIndex);\n                var value = changeTree.getValue(fieldIndex);\n                // Enqueue ChangeTree to be visited\n                if (value &&\n                    value['$changes'] &&\n                    !refIdsVisited.has(value['$changes'])) {\n                    changeTrees.push(value['$changes']);\n                    value['$changes'].ensureRefId();\n                    numChangeTrees++;\n                }\n                if (operation.op === spec_1.OPERATION.TOUCH) {\n                    continue;\n                }\n                if (Schema.is(type)) {\n                    assertInstanceType(value, type, ref, field);\n                    //\n                    // Encode refId for this instance.\n                    // The actual instance is going to be encoded on next `changeTree` iteration.\n                    //\n                    encode.number(bytes, value.$changes.refId);\n                    // Try to encode inherited TYPE_ID if it's an ADD operation.\n                    if ((operation.op & spec_1.OPERATION.ADD) === spec_1.OPERATION.ADD) {\n                        this.tryEncodeTypeId(bytes, type, value.constructor);\n                    }\n                }\n                else if (typeof (type) === \"string\") {\n                    //\n                    // Primitive values\n                    //\n                    encodePrimitiveType(type, bytes, value, ref, field);\n                }\n                else {\n                    //\n                    // Custom type (MapSchema, ArraySchema, etc)\n                    //\n                    var definition = types_1.getType(Object.keys(type)[0]);\n                    //\n                    // ensure a ArraySchema has been provided\n                    //\n                    assertInstanceType(ref[\"_\" + field], definition.constructor, ref, field);\n                    //\n                    // Encode refId for this instance.\n                    // The actual instance is going to be encoded on next `changeTree` iteration.\n                    //\n                    encode.number(bytes, value.$changes.refId);\n                }\n                if (useFilters) {\n                    // cache begin / end index\n                    changeTree.cache(fieldIndex, bytes.slice(beginIndex));\n                }\n            }\n            if (!encodeAll && !useFilters) {\n                changeTree.discard();\n            }\n        }\n        return bytes;\n    };\n    Schema.prototype.encodeAll = function (useFilters) {\n        return this.encode(true, [], useFilters);\n    };\n    Schema.prototype.applyFilters = function (client, encodeAll) {\n        if (encodeAll === void 0) { encodeAll = false; }\n        var root = this;\n        var refIdsDissallowed = new Set();\n        var $filterState = filters_1.ClientState.get(client);\n        var changeTrees = [this.$changes];\n        var numChangeTrees = 1;\n        var filteredBytes = [];\n        var _loop_1 = function (i) {\n            var changeTree = changeTrees[i];\n            if (refIdsDissallowed.has(changeTree.refId)) {\n                return \"continue\";\n            }\n            var ref = changeTree.ref;\n            var isSchema = ref instanceof Schema;\n            encode.uint8(filteredBytes, spec_1.SWITCH_TO_STRUCTURE);\n            encode.number(filteredBytes, changeTree.refId);\n            var clientHasRefId = $filterState.refIds.has(changeTree);\n            var isEncodeAll = (encodeAll || !clientHasRefId);\n            // console.log(\"REF:\", ref.constructor.name);\n            // console.log(\"Encode all?\", isEncodeAll);\n            //\n            // include `changeTree` on list of known refIds by this client.\n            //\n            $filterState.addRefId(changeTree);\n            var containerIndexes = $filterState.containerIndexes.get(changeTree);\n            var changes = (isEncodeAll)\n                ? Array.from(changeTree.allChanges)\n                : Array.from(changeTree.changes.values());\n            //\n            // WORKAROUND: tries to re-evaluate previously not included @filter() attributes\n            // - see \"DELETE a field of Schema\" test case.\n            //\n            if (!encodeAll &&\n                isSchema &&\n                ref._definition.indexesWithFilters) {\n                var indexesWithFilters = ref._definition.indexesWithFilters;\n                indexesWithFilters.forEach(function (indexWithFilter) {\n                    if (!containerIndexes.has(indexWithFilter) &&\n                        changeTree.allChanges.has(indexWithFilter)) {\n                        if (isEncodeAll) {\n                            changes.push(indexWithFilter);\n                        }\n                        else {\n                            changes.push({ op: spec_1.OPERATION.ADD, index: indexWithFilter, });\n                        }\n                    }\n                });\n            }\n            for (var j = 0, cl = changes.length; j < cl; j++) {\n                var change = (isEncodeAll)\n                    ? { op: spec_1.OPERATION.ADD, index: changes[j] }\n                    : changes[j];\n                // custom operations\n                if (change.op === spec_1.OPERATION.CLEAR) {\n                    encode.uint8(filteredBytes, change.op);\n                    continue;\n                }\n                var fieldIndex = change.index;\n                //\n                // Deleting fields: encode the operation + field index\n                //\n                if (change.op === spec_1.OPERATION.DELETE) {\n                    //\n                    // DELETE operations also need to go through filtering.\n                    //\n                    // TODO: cache the previous value so we can access the value (primitive or `refId`)\n                    // (check against `$filterState.refIds`)\n                    //\n                    if (isSchema) {\n                        encode.uint8(filteredBytes, change.op | fieldIndex);\n                    }\n                    else {\n                        encode.uint8(filteredBytes, change.op);\n                        encode.number(filteredBytes, fieldIndex);\n                    }\n                    continue;\n                }\n                // indexed operation\n                var value = changeTree.getValue(fieldIndex);\n                var type = changeTree.getType(fieldIndex);\n                if (isSchema) {\n                    // Is a Schema!\n                    var filter = (ref._definition.filters &&\n                        ref._definition.filters[fieldIndex]);\n                    if (filter && !filter.call(ref, client, value, root)) {\n                        if (value && value['$changes']) {\n                            refIdsDissallowed.add(value['$changes'].refId);\n                            ;\n                        }\n                        continue;\n                    }\n                }\n                else {\n                    // Is a collection! (map, array, etc.)\n                    var parent = changeTree.parent;\n                    var filter = changeTree.getChildrenFilter();\n                    if (filter && !filter.call(parent, client, ref['$indexes'].get(fieldIndex), value, root)) {\n                        if (value && value['$changes']) {\n                            refIdsDissallowed.add(value['$changes'].refId);\n                        }\n                        continue;\n                    }\n                }\n                // visit child ChangeTree on further iteration.\n                if (value['$changes']) {\n                    changeTrees.push(value['$changes']);\n                    numChangeTrees++;\n                }\n                //\n                // Copy cached bytes\n                //\n                if (change.op !== spec_1.OPERATION.TOUCH) {\n                    //\n                    // TODO: refactor me!\n                    //\n                    if (change.op === spec_1.OPERATION.ADD || isSchema) {\n                        //\n                        // use cached bytes directly if is from Schema type.\n                        //\n                        filteredBytes = filteredBytes.concat(changeTree.caches[fieldIndex]);\n                        containerIndexes.add(fieldIndex);\n                    }\n                    else {\n                        if (containerIndexes.has(fieldIndex)) {\n                            //\n                            // use cached bytes if already has the field\n                            //\n                            filteredBytes = filteredBytes.concat(changeTree.caches[fieldIndex]);\n                        }\n                        else {\n                            //\n                            // force ADD operation if field is not known by this client.\n                            //\n                            containerIndexes.add(fieldIndex);\n                            encode.uint8(filteredBytes, spec_1.OPERATION.ADD);\n                            encode.number(filteredBytes, fieldIndex);\n                            if (ref instanceof MapSchema_1.MapSchema) {\n                                //\n                                // MapSchema dynamic key\n                                //\n                                var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);\n                                encode.string(filteredBytes, dynamicIndex);\n                            }\n                            if (value['$changes']) {\n                                encode.number(filteredBytes, value['$changes'].refId);\n                            }\n                            else {\n                                // \"encodePrimitiveType\" without type checking.\n                                // the type checking has been done on the first .encode() call.\n                                encode[type](filteredBytes, value);\n                            }\n                        }\n                    }\n                }\n                else if (value['$changes'] && !isSchema) {\n                    //\n                    // TODO:\n                    // - track ADD/REPLACE/DELETE instances on `$filterState`\n                    // - do NOT always encode dynamicIndex for MapSchema.\n                    //   (If client already has that key, only the first index is necessary.)\n                    //\n                    encode.uint8(filteredBytes, spec_1.OPERATION.ADD);\n                    encode.number(filteredBytes, fieldIndex);\n                    if (ref instanceof MapSchema_1.MapSchema) {\n                        //\n                        // MapSchema dynamic key\n                        //\n                        var dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);\n                        encode.string(filteredBytes, dynamicIndex);\n                    }\n                    encode.number(filteredBytes, value['$changes'].refId);\n                }\n            }\n            ;\n        };\n        for (var i = 0; i < numChangeTrees; i++) {\n            _loop_1(i);\n        }\n        return filteredBytes;\n    };\n    Schema.prototype.clone = function () {\n        var cloned = new (this.constructor);\n        var schema = this._definition.schema;\n        for (var field in schema) {\n            if (typeof (this[field]) === \"object\" &&\n                typeof (this[field].clone) === \"function\") {\n                // deep clone\n                cloned[field] = this[field].clone();\n            }\n            else {\n                // primitive values\n                cloned[field] = this[field];\n            }\n        }\n        return cloned;\n    };\n    Schema.prototype.triggerAll = function () {\n        // skip if haven't received any remote refs yet.\n        if (this.$changes.root.refs.size === 0) {\n            return;\n        }\n        var allChanges = new Map();\n        Schema.prototype._triggerAllFillChanges.call(this, this, allChanges);\n        try {\n            Schema.prototype._triggerChanges.call(this, allChanges);\n        }\n        catch (e) {\n            Schema.onError(e);\n        }\n    };\n    Schema.prototype.toJSON = function () {\n        var schema = this._definition.schema;\n        var deprecated = this._definition.deprecated;\n        var obj = {};\n        for (var field in schema) {\n            if (!deprecated[field] && this[field] !== null && typeof (this[field]) !== \"undefined\") {\n                obj[field] = (typeof (this[field]['toJSON']) === \"function\")\n                    ? this[field]['toJSON']()\n                    : this[\"_\" + field];\n            }\n        }\n        return obj;\n    };\n    Schema.prototype.discardAllChanges = function () {\n        this.$changes.discardAll();\n    };\n    Schema.prototype.getByIndex = function (index) {\n        return this[this._definition.fieldsByIndex[index]];\n    };\n    Schema.prototype.deleteByIndex = function (index) {\n        this[this._definition.fieldsByIndex[index]] = undefined;\n    };\n    Schema.prototype.tryEncodeTypeId = function (bytes, type, targetType) {\n        if (type._typeid !== targetType._typeid) {\n            encode.uint8(bytes, spec_1.TYPE_ID);\n            encode.number(bytes, targetType._typeid);\n        }\n    };\n    Schema.prototype.getSchemaType = function (bytes, it, defaultType) {\n        var type;\n        if (bytes[it.offset] === spec_1.TYPE_ID) {\n            it.offset++;\n            type = this.constructor._context.get(decode.number(bytes, it));\n        }\n        return type || defaultType;\n    };\n    Schema.prototype.createTypeInstance = function (type) {\n        var instance = new type();\n        // assign root on $changes\n        instance.$changes.root = this.$changes.root;\n        return instance;\n    };\n    Schema.prototype._triggerAllFillChanges = function (ref, allChanges) {\n        if (allChanges.has(ref['$changes'].refId)) {\n            return;\n        }\n        var changes = [];\n        allChanges.set(ref['$changes'].refId || 0, changes);\n        if (ref instanceof Schema) {\n            var schema = ref._definition.schema;\n            for (var fieldName in schema) {\n                var _field = \"_\" + fieldName;\n                var value = ref[_field];\n                if (value !== undefined) {\n                    changes.push({\n                        op: spec_1.OPERATION.ADD,\n                        field: fieldName,\n                        value: value,\n                        previousValue: undefined\n                    });\n                    if (value['$changes'] !== undefined) {\n                        Schema.prototype._triggerAllFillChanges.call(this, value, allChanges);\n                    }\n                }\n            }\n        }\n        else {\n            var entries = ref.entries();\n            var iter = void 0;\n            while ((iter = entries.next()) && !iter.done) {\n                var _a = __read(iter.value, 2), key = _a[0], value = _a[1];\n                changes.push({\n                    op: spec_1.OPERATION.ADD,\n                    field: key,\n                    dynamicIndex: key,\n                    value: value,\n                    previousValue: undefined,\n                });\n                if (value['$changes'] !== undefined) {\n                    Schema.prototype._triggerAllFillChanges.call(this, value, allChanges);\n                }\n            }\n        }\n    };\n    Schema.prototype._triggerChanges = function (allChanges) {\n        var _this = this;\n        allChanges.forEach(function (changes, refId) {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;\n            if (changes.length > 0) {\n                var ref = _this.$changes.root.refs.get(refId);\n                var isSchema = ref instanceof Schema;\n                for (var i = 0; i < changes.length; i++) {\n                    var change = changes[i];\n                    var listener = ref['$listeners'] && ref['$listeners'][change.field];\n                    if (!isSchema) {\n                        if (change.op === spec_1.OPERATION.ADD && change.previousValue === undefined) {\n                            (_b = (_a = ref).onAdd) === null || _b === void 0 ? void 0 : _b.call(_a, change.value, (_c = change.dynamicIndex) !== null && _c !== void 0 ? _c : change.field);\n                        }\n                        else if (change.op === spec_1.OPERATION.DELETE) {\n                            //\n                            // FIXME: `previousValue` should always be avaiiable.\n                            // ADD + DELETE operations are still encoding DELETE operation.\n                            //\n                            if (change.previousValue !== undefined) {\n                                (_e = (_d = ref).onRemove) === null || _e === void 0 ? void 0 : _e.call(_d, change.previousValue, (_f = change.dynamicIndex) !== null && _f !== void 0 ? _f : change.field);\n                            }\n                        }\n                        else if (change.op === spec_1.OPERATION.DELETE_AND_ADD) {\n                            if (change.previousValue !== undefined) {\n                                (_h = (_g = ref).onRemove) === null || _h === void 0 ? void 0 : _h.call(_g, change.previousValue, change.dynamicIndex);\n                            }\n                            (_k = (_j = ref).onAdd) === null || _k === void 0 ? void 0 : _k.call(_j, change.value, change.dynamicIndex);\n                        }\n                        else if (change.op === spec_1.OPERATION.REPLACE ||\n                            change.value !== change.previousValue) {\n                            (_m = (_l = ref).onChange) === null || _m === void 0 ? void 0 : _m.call(_l, change.value, change.dynamicIndex);\n                        }\n                    }\n                    //\n                    // trigger onRemove on child structure.\n                    //\n                    if ((change.op & spec_1.OPERATION.DELETE) === spec_1.OPERATION.DELETE &&\n                        change.previousValue instanceof Schema &&\n                        change.previousValue.onRemove) {\n                        change.previousValue.onRemove();\n                    }\n                    if (listener) {\n                        try {\n                            listener.invoke(change.value, change.previousValue);\n                        }\n                        catch (e) {\n                            Schema.onError(e);\n                        }\n                    }\n                }\n                if (isSchema) {\n                    if (ref.onChange) {\n                        try {\n                            ref.onChange(changes);\n                        }\n                        catch (e) {\n                            Schema.onError(e);\n                        }\n                    }\n                }\n            }\n        });\n    };\n    Schema._definition = annotations_1.SchemaDefinition.create();\n    return Schema;\n}());\nexports.Schema = Schema;\n"},"sourceMaps":{"js":{"version":3,"file":"Schema.js","sourceRoot":"","sources":["../src/Schema.ts"],"names":[],"mappings":"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","sourcesContent":["import { SWITCH_TO_STRUCTURE, TYPE_ID, OPERATION } from './spec';\nimport { Client, PrimitiveType, Context, SchemaDefinition, DefinitionType } from \"./annotations\";\n\nimport * as encode from \"./encoding/encode\";\nimport * as decode from \"./encoding/decode\";\n\nimport { ArraySchema } from \"./types/ArraySchema\";\nimport { MapSchema } from \"./types/MapSchema\";\nimport { CollectionSchema } from './types/CollectionSchema';\nimport { SetSchema } from './types/SetSchema';\n\nimport { ChangeTree, Root, Ref, ChangeOperation } from \"./changes/ChangeTree\";\nimport { NonFunctionPropNames } from './types/HelperTypes';\nimport { EventEmitter } from './events/EventEmitter';\nimport { ClientState } from './filters';\nimport { getType } from './types';\n\nexport interface DataChange<T=any> {\n    op: OPERATION,\n    field: string;\n    dynamicIndex?: number | string;\n    value: T;\n    previousValue: T;\n}\n\nexport interface SchemaDecoderCallbacks {\n    onAdd?: (item: any, key: any) => void;\n    onRemove?: (item: any, key: any) => void;\n    onChange?: (item: any, key: any) => void;\n    clone(decoding?: boolean): SchemaDecoderCallbacks;\n    clear(decoding?: boolean);\n    decode?(byte, it: decode.Iterator);\n}\n\nclass EncodeSchemaError extends Error {}\n\nfunction assertType(value: any, type: string, klass: Schema, field: string | number) {\n    let typeofTarget: string;\n    let allowNull: boolean = false;\n\n    switch (type) {\n        case \"number\":\n        case \"int8\":\n        case \"uint8\":\n        case \"int16\":\n        case \"uint16\":\n        case \"int32\":\n        case \"uint32\":\n        case \"int64\":\n        case \"uint64\":\n        case \"float32\":\n        case \"float64\":\n            typeofTarget = \"number\";\n            if (isNaN(value)) {\n                console.log(`trying to encode \"NaN\" in ${klass.constructor.name}#${field}`);\n            }\n            break;\n        case \"string\":\n            typeofTarget = \"string\";\n            allowNull = true;\n            break;\n        case \"boolean\":\n            // boolean is always encoded as true/false based on truthiness\n            return;\n    }\n\n    if (typeof (value) !== typeofTarget && (!allowNull || (allowNull && value !== null))) {\n        let foundValue = `'${JSON.stringify(value)}'${(value && value.constructor && ` (${value.constructor.name})`) || ''}`;\n        throw new EncodeSchemaError(`a '${typeofTarget}' was expected, but ${foundValue} was provided in ${klass.constructor.name}#${field}`);\n    }\n}\n\nfunction assertInstanceType(\n    value: Schema,\n    type: typeof Schema\n        | typeof ArraySchema\n        | typeof MapSchema\n        | typeof CollectionSchema\n        | typeof SetSchema,\n    klass: Schema,\n    field: string | number,\n) {\n    if (!(value instanceof type)) {\n        throw new EncodeSchemaError(`a '${type.name}' was expected, but '${(value as any).constructor.name}' was provided in ${klass.constructor.name}#${field}`);\n    }\n}\n\nfunction encodePrimitiveType(\n    type: PrimitiveType,\n    bytes: number[],\n    value: any,\n    klass: Schema,\n    field: string | number,\n) {\n    assertType(value, type as string, klass, field);\n\n    const encodeFunc = encode[type as string];\n\n    if (encodeFunc) {\n        encodeFunc(bytes, value);\n\n    } else {\n        throw new EncodeSchemaError(`a '${type}' was expected, but ${value} was provided in ${klass.constructor.name}#${field}`);\n    }\n}\n\nfunction decodePrimitiveType (type: string, bytes: number[], it: decode.Iterator) {\n    return decode[type as string](bytes, it);\n}\n\n/**\n * Schema encoder / decoder\n */\nexport abstract class Schema {\n    static _typeid: number;\n    static _context: Context;\n\n    static _definition: SchemaDefinition = SchemaDefinition.create();\n\n    static onError(e) {\n        console.error(e);\n    }\n\n    static is(type: DefinitionType) {\n        return (\n            type['_definition'] &&\n            type['_definition'].schema !== undefined\n        );\n    }\n\n    protected $changes: ChangeTree;\n    // protected $root: ChangeSet;\n\n    protected $listeners: { [field: string]: EventEmitter<(a: any, b: any) => void> };\n\n    public onChange?(changes: DataChange[]);\n    public onRemove?();\n\n    // allow inherited classes to have a constructor\n    constructor(...args: any[]) {\n        // fix enumerability of fields for end-user\n        Object.defineProperties(this, {\n            $changes: {\n                value: new ChangeTree(this, undefined, new Root()),\n                enumerable: false,\n                writable: true\n            },\n\n            $listeners: {\n                value: {},\n                enumerable: false,\n                writable: true\n            },\n        });\n\n        const descriptors = this._definition.descriptors;\n        if (descriptors) {\n            Object.defineProperties(this, descriptors);\n        }\n\n        //\n        // Assign initial values\n        //\n        if (args[0]) {\n            this.assign(args[0]);\n        }\n    }\n\n    public assign(\n        props: { [prop in NonFunctionPropNames<this>]?: this[prop] }\n    ) {\n        Object.assign(this, props);\n        return this;\n    }\n\n    protected get _definition () { return (this.constructor as typeof Schema)._definition; }\n\n    public listen <K extends NonFunctionPropNames<this>>(attr: K, callback: (value: this[K], previousValue: this[K]) => void) {\n        if (!this.$listeners[attr as string]) {\n            this.$listeners[attr as string] = new EventEmitter();\n        }\n        this.$listeners[attr as string].register(callback);\n\n        // return un-register callback.\n        return () =>\n            this.$listeners[attr as string].remove(callback);\n    }\n\n    decode(\n        bytes: number[],\n        it: decode.Iterator = { offset: 0 },\n        ref: Ref = this,\n        allChanges: Map<number, DataChange[]> = new Map<number, DataChange[]>(),\n    ) {\n        const $root = this.$changes.root;\n        const totalBytes = bytes.length;\n\n        let refId: number = 0;\n        let changes: DataChange[] = [];\n\n        $root.refs.set(refId, this);\n        allChanges.set(refId, changes);\n\n        while (it.offset < totalBytes) {\n            let byte = bytes[it.offset++];\n\n            if (byte == SWITCH_TO_STRUCTURE) {\n                refId = decode.number(bytes, it);\n\n                const nextRef = $root.refs.get(refId) as Schema;\n\n                //\n                // Trying to access a reference that haven't been decoded yet.\n                //\n                if (!nextRef) { throw new Error(`\"refId\" not found: ${refId}`); }\n\n                ref = nextRef;\n\n                // create empty list of changes for this refId.\n                changes = [];\n                allChanges.set(refId, changes);\n\n                continue;\n            }\n\n            const changeTree: ChangeTree = ref['$changes'];\n            const isSchema = (ref['_definition'] !== undefined);\n\n            const operation = (isSchema)\n                ? (byte >> 6) << 6 // \"compressed\" index + operation\n                : byte; // \"uncompressed\" index + operation (array/map items)\n\n            if (operation === OPERATION.CLEAR) {\n                //\n                // TODO: refactor me!\n                // The `.clear()` method is calling `$root.removeRef(refId)` for\n                // each item inside this collection\n                //\n                (ref as SchemaDecoderCallbacks).clear(true);\n                continue;\n            }\n\n            const fieldIndex = (isSchema)\n                ? byte % (operation || 255) // if \"REPLACE\" operation (0), use 255\n                : decode.number(bytes, it);\n\n            const fieldName = (isSchema)\n                ? (ref['_definition'].fieldsByIndex[fieldIndex])\n                : \"\";\n\n            let type = changeTree.getType(fieldIndex);\n            let value: any;\n            let previousValue: any;\n\n            let dynamicIndex: number | string;\n\n            if (!isSchema) {\n                previousValue = ref['getByIndex'](fieldIndex);\n\n                if ((operation & OPERATION.ADD) === OPERATION.ADD) { // ADD or DELETE_AND_ADD\n                    dynamicIndex = (ref instanceof MapSchema)\n                        ? decode.string(bytes, it)\n                        : fieldIndex;\n                    ref['setIndex'](fieldIndex, dynamicIndex);\n\n                } else {\n                    // here\n                    dynamicIndex = ref['getIndex'](fieldIndex);\n                }\n\n            } else {\n                previousValue = ref[`_${fieldName}`];\n            }\n\n            //\n            // Delete operations\n            //\n            if ((operation & OPERATION.DELETE) === OPERATION.DELETE)\n            {\n                if (operation !== OPERATION.DELETE_AND_ADD) {\n                    ref['deleteByIndex'](fieldIndex);\n                }\n\n                // Flag `refId` for garbage collection.\n                if (previousValue && previousValue['$changes']) {\n                    $root.removeRef(previousValue['$changes'].refId);\n                }\n\n                value = null;\n            }\n\n            if (fieldName === undefined) {\n                console.warn(\"@colyseus/schema: definition mismatch\");\n\n                //\n                // keep skipping next bytes until reaches a known structure\n                // by local decoder.\n                //\n                const nextIterator: decode.Iterator = { offset: it.offset };\n                while (it.offset < totalBytes) {\n                    if (decode.switchStructureCheck(bytes, it)) {\n                        nextIterator.offset = it.offset + 1;\n                        if ($root.refs.has(decode.number(bytes, nextIterator))) {\n                            break;\n                        }\n                    }\n\n                    it.offset++;\n                }\n\n                continue;\n\n            } else if (operation === OPERATION.DELETE) {\n                //\n                // FIXME: refactor me.\n                // Don't do anything.\n                //\n\n            } else if (Schema.is(type)) {\n                const refId = decode.number(bytes, it);\n                value = $root.refs.get(refId);\n\n                if (operation !== OPERATION.REPLACE) {\n                    const childType = this.getSchemaType(bytes, it, type);\n\n                    if (!value) {\n                        value = this.createTypeInstance(childType);\n                        value.$changes.refId = refId;\n\n                        if (previousValue) {\n                            value.onChange = previousValue.onChange;\n                            value.onRemove = previousValue.onRemove;\n                            value.$listeners = previousValue.$listeners;\n\n                            if (\n                                previousValue['$changes'].refId &&\n                                refId !== previousValue['$changes'].refId\n                            ) {\n                                $root.removeRef(previousValue['$changes'].refId);\n                            }\n                        }\n                    }\n\n                    $root.addRef(refId, value, (value !== previousValue));\n                }\n            } else if (typeof(type) === \"string\") {\n                //\n                // primitive value (number, string, boolean, etc)\n                //\n                value = decodePrimitiveType(type as string, bytes, it);\n\n            } else {\n                const typeDef = getType(Object.keys(type)[0]);\n                const refId = decode.number(bytes, it);\n\n                const valueRef: SchemaDecoderCallbacks = ($root.refs.has(refId))\n                    ? previousValue || $root.refs.get(refId)\n                    : new typeDef.constructor();\n\n                value = valueRef.clone(true);\n                value.$changes.refId = refId;\n\n                // preserve schema callbacks\n                if (previousValue) {\n                    value.onAdd = previousValue.onAdd;\n                    value.onRemove = previousValue.onRemove;\n                    value.onChange = previousValue.onChange;\n\n                    if (\n                        previousValue['$changes'].refId &&\n                        refId !== previousValue['$changes'].refId\n                    ) {\n                        $root.removeRef(previousValue['$changes'].refId);\n\n                        //\n                        // Trigger onRemove if structure has been replaced.\n                        //\n                        const deletes: DataChange[] = [];\n                        const entries: IterableIterator<[any, any]> = previousValue.entries();\n                        let iter: IteratorResult<[any, any]>;\n                        while ((iter = entries.next()) && !iter.done) {\n                            const [key, value] = iter.value;\n                            deletes.push({\n                                op: OPERATION.DELETE,\n                                field: key,\n                                value: undefined,\n                                previousValue: value,\n                            });\n                        }\n\n                        allChanges.set(previousValue['$changes'].refId, deletes);\n                    }\n                }\n\n                $root.addRef(refId, value, (valueRef !== previousValue));\n\n                //\n                // TODO: deprecate proxies on next version.\n                // get proxy to target value.\n                //\n                if (typeDef.getProxy) {\n                    value = typeDef.getProxy(value);\n                }\n            }\n\n            let hasChange = (previousValue !== value);\n\n            if (\n                value !== null &&\n                value !== undefined\n            ) {\n                if (value['$changes']) {\n                    value['$changes'].setParent(\n                        changeTree.ref,\n                        changeTree.root,\n                        fieldIndex,\n                    );\n                }\n\n                if (ref instanceof Schema) {\n                    ref[fieldName] = value;\n\n                    //\n                    // FIXME: use `_field` instead of `field`.\n                    //\n                    // `field` is going to use the setter of the PropertyDescriptor\n                    // and create a proxy for array/map. This is only useful for\n                    // backwards-compatibility with @colyseus/schema@0.5.x\n                    //\n                    // // ref[_field] = value;\n\n                } else if (ref instanceof MapSchema) {\n                    // const key = ref['$indexes'].get(field);\n                    const key = dynamicIndex as string;\n\n                    // ref.set(key, value);\n                    ref['$items'].set(key, value);\n\n                } else if (ref instanceof ArraySchema) {\n                    // const key = ref['$indexes'][field];\n                    // console.log(\"SETTING FOR ArraySchema =>\", { field, key, value });\n                    // ref[key] = value;\n                    ref.setAt(fieldIndex, value);\n\n                } else if (\n                    ref instanceof CollectionSchema ||\n                    ref instanceof SetSchema\n                ) {\n                    const index = ref.add(value);\n                    ref['setIndex'](fieldIndex, index);\n                }\n            }\n\n            if (\n                hasChange\n                // &&\n                // (\n                //     this.onChange || ref.$listeners[field]\n                // )\n            ) {\n                changes.push({\n                    op: operation,\n                    field: fieldName,\n                    dynamicIndex,\n                    value,\n                    previousValue,\n                });\n            }\n        }\n\n        this._triggerChanges(allChanges);\n\n        // drop references of unused schemas\n        $root.garbageCollectDeletedRefs();\n\n        return allChanges;\n    }\n\n    encode(\n        encodeAll = false,\n        bytes: number[] = [],\n        useFilters: boolean = false,\n    ) {\n        const rootChangeTree = this.$changes;\n        const refIdsVisited = new WeakSet<ChangeTree>();\n\n        const changeTrees: ChangeTree[] = [rootChangeTree];\n        let numChangeTrees = 1;\n\n        for (let i = 0; i < numChangeTrees; i++) {\n            const changeTree = changeTrees[i];\n            const ref = changeTree.ref;\n            const isSchema = (ref instanceof Schema);\n\n            // Generate unique refId for the ChangeTree.\n            changeTree.ensureRefId();\n\n            // mark this ChangeTree as visited.\n            refIdsVisited.add(changeTree);\n\n            // root `refId` is skipped.\n            if (\n                changeTree !== rootChangeTree &&\n                (changeTree.changed || encodeAll)\n            ) {\n                encode.uint8(bytes, SWITCH_TO_STRUCTURE);\n                encode.number(bytes, changeTree.refId);\n            }\n\n            const changes: ChangeOperation[] | number[] = (encodeAll)\n                ? Array.from(changeTree.allChanges)\n                : Array.from(changeTree.changes.values());\n\n            for (let j = 0, cl = changes.length; j < cl; j++) {\n                const operation: ChangeOperation = (encodeAll)\n                    ? { op: OPERATION.ADD, index: changes[j] as number }\n                    : changes[j] as ChangeOperation;\n\n                const fieldIndex = operation.index;\n\n                const field = (isSchema)\n                    ? ref['_definition'].fieldsByIndex && ref['_definition'].fieldsByIndex[fieldIndex]\n                    : fieldIndex;\n\n                // cache begin index if `useFilters`\n                const beginIndex = bytes.length;\n\n                // encode field index + operation\n                if (operation.op !== OPERATION.TOUCH) {\n                    if (isSchema) {\n                        //\n                        // Compress `fieldIndex` + `operation` into a single byte.\n                        // This adds a limitaion of 64 fields per Schema structure\n                        //\n                        encode.uint8(bytes, (fieldIndex | operation.op));\n\n                    } else {\n                        encode.uint8(bytes, operation.op);\n\n                        // custom operations\n                        if (operation.op === OPERATION.CLEAR) {\n                            continue;\n                        }\n\n                        // indexed operations\n                        encode.number(bytes, fieldIndex);\n                    }\n                }\n\n                //\n                // encode \"alias\" for dynamic fields (maps)\n                //\n                if (\n                    !isSchema &&\n                    (operation.op & OPERATION.ADD) == OPERATION.ADD // ADD or DELETE_AND_ADD\n                ) {\n                    if (ref instanceof MapSchema) {\n                        //\n                        // MapSchema dynamic key\n                        //\n                        const dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);\n                        encode.string(bytes, dynamicIndex);\n                    }\n                }\n\n                if (operation.op === OPERATION.DELETE) {\n                    //\n                    // TODO: delete from filter cache data.\n                    //\n                    // if (useFilters) {\n                    //     delete changeTree.caches[fieldIndex];\n                    // }\n                    continue;\n                }\n\n                // const type = changeTree.childType || ref._schema[field];\n                const type = changeTree.getType(fieldIndex);\n\n                // const type = changeTree.getType(fieldIndex);\n                const value = changeTree.getValue(fieldIndex);\n\n                // Enqueue ChangeTree to be visited\n                if (\n                    value &&\n                    value['$changes'] &&\n                    !refIdsVisited.has(value['$changes'])\n                ) {\n                    changeTrees.push(value['$changes']);\n                    value['$changes'].ensureRefId();\n                    numChangeTrees++;\n                }\n\n                if (operation.op === OPERATION.TOUCH) {\n                    continue;\n                }\n\n                if (Schema.is(type)) {\n                    assertInstanceType(value, type as typeof Schema, ref as Schema, field);\n\n                    //\n                    // Encode refId for this instance.\n                    // The actual instance is going to be encoded on next `changeTree` iteration.\n                    //\n                    encode.number(bytes, value.$changes.refId);\n\n                    // Try to encode inherited TYPE_ID if it's an ADD operation.\n                    if ((operation.op & OPERATION.ADD) === OPERATION.ADD) {\n                        this.tryEncodeTypeId(bytes, type as typeof Schema, value.constructor as typeof Schema);\n                    }\n\n                } else if (typeof(type) === \"string\") {\n                    //\n                    // Primitive values\n                    //\n                    encodePrimitiveType(type as PrimitiveType, bytes, value, ref as Schema, field);\n\n                } else {\n                    //\n                    // Custom type (MapSchema, ArraySchema, etc)\n                    //\n                    const definition = getType(Object.keys(type)[0]);\n\n                    //\n                    // ensure a ArraySchema has been provided\n                    //\n                    assertInstanceType(ref[`_${field}`], definition.constructor, ref as Schema, field);\n\n                    //\n                    // Encode refId for this instance.\n                    // The actual instance is going to be encoded on next `changeTree` iteration.\n                    //\n                    encode.number(bytes, value.$changes.refId);\n                }\n\n                if (useFilters) {\n                    // cache begin / end index\n                    changeTree.cache(fieldIndex as number, bytes.slice(beginIndex));\n                }\n            }\n\n            if (!encodeAll && !useFilters) {\n                changeTree.discard();\n            }\n        }\n\n        return bytes;\n    }\n\n    encodeAll (useFilters?: boolean) {\n        return this.encode(true, [], useFilters);\n    }\n\n    applyFilters(client: Client, encodeAll: boolean = false) {\n        const root = this;\n        const refIdsDissallowed = new Set<number>();\n\n        const $filterState = ClientState.get(client);\n\n        const changeTrees = [this.$changes];\n        let numChangeTrees = 1;\n\n        let filteredBytes: number[] = [];\n\n        for (let i = 0; i < numChangeTrees; i++) {\n            const changeTree = changeTrees[i];\n\n            if (refIdsDissallowed.has(changeTree.refId))  {\n                // console.log(\"REFID IS NOT ALLOWED. SKIP.\", { refId: changeTree.refId })\n                continue;\n            }\n\n            const ref = changeTree.ref as Ref;\n            const isSchema: boolean = ref instanceof Schema;\n\n            encode.uint8(filteredBytes, SWITCH_TO_STRUCTURE);\n            encode.number(filteredBytes, changeTree.refId);\n\n            const clientHasRefId = $filterState.refIds.has(changeTree);\n            const isEncodeAll = (encodeAll || !clientHasRefId);\n\n            // console.log(\"REF:\", ref.constructor.name);\n            // console.log(\"Encode all?\", isEncodeAll);\n\n            //\n            // include `changeTree` on list of known refIds by this client.\n            //\n            $filterState.addRefId(changeTree);\n\n            const containerIndexes = $filterState.containerIndexes.get(changeTree)\n            const changes = (isEncodeAll)\n                ? Array.from(changeTree.allChanges)\n                : Array.from(changeTree.changes.values());\n\n            //\n            // WORKAROUND: tries to re-evaluate previously not included @filter() attributes\n            // - see \"DELETE a field of Schema\" test case.\n            //\n            if (\n                !encodeAll &&\n                isSchema &&\n                (ref as Schema)._definition.indexesWithFilters\n            ) {\n                const indexesWithFilters = (ref as Schema)._definition.indexesWithFilters;\n                indexesWithFilters.forEach(indexWithFilter => {\n                    if (\n                        !containerIndexes.has(indexWithFilter) &&\n                        changeTree.allChanges.has(indexWithFilter)\n                    ) {\n                        if (isEncodeAll) {\n                            changes.push(indexWithFilter as any);\n\n                        } else {\n                            changes.push({ op: OPERATION.ADD, index: indexWithFilter, } as any);\n                        }\n                    }\n                });\n            }\n\n            for (let j = 0, cl = changes.length; j < cl; j++) {\n                const change: ChangeOperation = (isEncodeAll)\n                    ? { op: OPERATION.ADD, index: changes[j] as number }\n                    : changes[j] as ChangeOperation;\n\n                // custom operations\n                if (change.op === OPERATION.CLEAR) {\n                    encode.uint8(filteredBytes, change.op);\n                    continue;\n                }\n\n                const fieldIndex = change.index;\n\n                //\n                // Deleting fields: encode the operation + field index\n                //\n                if (change.op === OPERATION.DELETE) {\n                    //\n                    // DELETE operations also need to go through filtering.\n                    //\n                    // TODO: cache the previous value so we can access the value (primitive or `refId`)\n                    // (check against `$filterState.refIds`)\n                    //\n\n                    if (isSchema) {\n                        encode.uint8(filteredBytes, change.op | fieldIndex);\n\n                    } else {\n                        encode.uint8(filteredBytes, change.op);\n                        encode.number(filteredBytes, fieldIndex);\n\n                    }\n                    continue;\n                }\n\n                // indexed operation\n                const value = changeTree.getValue(fieldIndex);\n                const type = changeTree.getType(fieldIndex);\n\n                if (isSchema) {\n                    // Is a Schema!\n                    const filter = (\n                        (ref as Schema)._definition.filters &&\n                        (ref as Schema)._definition.filters[fieldIndex]\n                    );\n\n                    if (filter && !filter.call(ref, client, value, root)) {\n                        if (value && value['$changes']) {\n                            refIdsDissallowed.add(value['$changes'].refId);;\n                        }\n                        continue;\n                    }\n\n                } else {\n                    // Is a collection! (map, array, etc.)\n                    const parent = changeTree.parent as Ref;\n                    const filter = changeTree.getChildrenFilter();\n\n                    if (filter && !filter.call(parent, client, ref['$indexes'].get(fieldIndex), value, root)) {\n                        if (value && value['$changes']) {\n                            refIdsDissallowed.add(value['$changes'].refId);\n                        }\n                        continue;\n                    }\n                }\n\n                // visit child ChangeTree on further iteration.\n                if (value['$changes']) {\n                    changeTrees.push(value['$changes']);\n                    numChangeTrees++;\n                }\n\n                //\n                // Copy cached bytes\n                //\n                if (change.op !== OPERATION.TOUCH) {\n\n                    //\n                    // TODO: refactor me!\n                    //\n\n                    if (change.op === OPERATION.ADD || isSchema) {\n                        //\n                        // use cached bytes directly if is from Schema type.\n                        //\n                        filteredBytes = filteredBytes.concat(changeTree.caches[fieldIndex]);\n                        containerIndexes.add(fieldIndex);\n\n                    } else {\n                        if (containerIndexes.has(fieldIndex)) {\n                            //\n                            // use cached bytes if already has the field\n                            //\n                            filteredBytes = filteredBytes.concat(changeTree.caches[fieldIndex]);\n\n                        } else {\n                            //\n                            // force ADD operation if field is not known by this client.\n                            //\n                            containerIndexes.add(fieldIndex);\n\n                            encode.uint8(filteredBytes, OPERATION.ADD);\n                            encode.number(filteredBytes, fieldIndex);\n\n                            if (ref instanceof MapSchema) {\n                                //\n                                // MapSchema dynamic key\n                                //\n                                const dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);\n                                encode.string(filteredBytes, dynamicIndex);\n                            }\n\n                            if (value['$changes']) {\n                                encode.number(filteredBytes, value['$changes'].refId);\n\n                            } else {\n                                // \"encodePrimitiveType\" without type checking.\n                                // the type checking has been done on the first .encode() call.\n                                encode[type as string](filteredBytes, value);\n                            }\n                        }\n                    }\n\n                } else if (value['$changes'] && !isSchema) {\n                    //\n                    // TODO:\n                    // - track ADD/REPLACE/DELETE instances on `$filterState`\n                    // - do NOT always encode dynamicIndex for MapSchema.\n                    //   (If client already has that key, only the first index is necessary.)\n                    //\n\n                    encode.uint8(filteredBytes, OPERATION.ADD);\n                    encode.number(filteredBytes, fieldIndex);\n\n                    if (ref instanceof MapSchema) {\n                        //\n                        // MapSchema dynamic key\n                        //\n                        const dynamicIndex = changeTree.ref['$indexes'].get(fieldIndex);\n                        encode.string(filteredBytes, dynamicIndex);\n                    }\n\n                    encode.number(filteredBytes, value['$changes'].refId);\n                }\n\n            };\n        }\n\n        return filteredBytes;\n    }\n\n    clone (): this {\n        const cloned = new ((this as any).constructor);\n        const schema = this._definition.schema;\n        for (let field in schema) {\n            if (\n                typeof (this[field]) === \"object\" &&\n                typeof (this[field].clone) === \"function\"\n            ) {\n                // deep clone\n                cloned[field] = this[field].clone();\n\n            } else {\n                // primitive values\n                cloned[field] = this[field];\n            }\n        }\n        return cloned;\n    }\n\n    triggerAll() {\n        // skip if haven't received any remote refs yet.\n        if (this.$changes.root.refs.size === 0) { return; }\n\n        const allChanges = new Map<number, DataChange[]>();\n        Schema.prototype._triggerAllFillChanges.call(this, this, allChanges);\n\n        try {\n            Schema.prototype._triggerChanges.call(this, allChanges);\n\n        } catch (e) {\n            Schema.onError(e);\n        }\n    }\n\n    toJSON () {\n        const schema = this._definition.schema;\n        const deprecated = this._definition.deprecated;\n\n        const obj = {}\n        for (let field in schema) {\n            if (!deprecated[field] && this[field] !== null && typeof (this[field]) !== \"undefined\") {\n                obj[field] = (typeof (this[field]['toJSON']) === \"function\")\n                    ? this[field]['toJSON']()\n                    : this[`_${field}`];\n            }\n        }\n        return obj;\n    }\n\n    discardAllChanges() {\n        this.$changes.discardAll();\n    }\n\n    protected getByIndex(index: number) {\n        return this[this._definition.fieldsByIndex[index]];\n    }\n\n    protected deleteByIndex(index: number) {\n        this[this._definition.fieldsByIndex[index]] = undefined;\n    }\n\n    private tryEncodeTypeId (bytes: number[], type: typeof Schema, targetType: typeof Schema) {\n        if (type._typeid !== targetType._typeid) {\n            encode.uint8(bytes, TYPE_ID);\n            encode.number(bytes, targetType._typeid);\n        }\n    }\n\n    private getSchemaType(bytes: number[], it: decode.Iterator, defaultType: typeof Schema): typeof Schema {\n        let type: typeof Schema;\n\n        if (bytes[it.offset] === TYPE_ID) {\n            it.offset++;\n            type = (this.constructor as typeof Schema)._context.get(decode.number(bytes, it));\n        }\n\n        return type || defaultType;\n    }\n\n    private createTypeInstance (type: typeof Schema): Schema {\n        let instance: Schema = new (type as any)();\n\n        // assign root on $changes\n        instance.$changes.root = this.$changes.root;\n\n        return instance;\n    }\n\n    private _triggerAllFillChanges(ref: Ref, allChanges: Map<number, DataChange[]>) {\n        if (allChanges.has(ref['$changes'].refId)) { return; }\n\n        const changes: DataChange[] = [];\n        allChanges.set(ref['$changes'].refId || 0, changes);\n\n        if (ref instanceof Schema) {\n            const schema = ref._definition.schema;\n\n            for (let fieldName in schema) {\n                const _field = `_${fieldName}`;\n                const value = ref[_field];\n\n                if (value !== undefined) {\n                    changes.push({\n                        op: OPERATION.ADD,\n                        field: fieldName,\n                        value,\n                        previousValue: undefined\n                    });\n\n                    if (value['$changes'] !== undefined) {\n                        Schema.prototype._triggerAllFillChanges.call(this, value, allChanges);\n                    }\n\n                }\n            }\n\n        } else {\n            const entries: IterableIterator<[any, any]>  = ref.entries();\n            let iter: IteratorResult<[any, any]>;\n\n            while ((iter = entries.next()) && !iter.done) {\n                const [key, value] = iter.value;\n\n                changes.push({\n                    op: OPERATION.ADD,\n                    field: key,\n                    dynamicIndex: key,\n                    value: value,\n                    previousValue: undefined,\n                });\n\n                if (value['$changes'] !== undefined) {\n                    Schema.prototype._triggerAllFillChanges.call(this, value, allChanges);\n                }\n            }\n        }\n    }\n\n    private _triggerChanges(allChanges: Map<number, DataChange[]>) {\n        allChanges.forEach((changes, refId) => {\n            if (changes.length > 0) {\n                const ref = this.$changes.root.refs.get(refId);\n                const isSchema = ref instanceof Schema;\n\n                for (let i = 0; i < changes.length; i++) {\n                    const change = changes[i];\n                    const listener = ref['$listeners'] && ref['$listeners'][change.field];\n\n                    if (!isSchema) {\n                        if (change.op === OPERATION.ADD && change.previousValue === undefined) {\n                            (ref as SchemaDecoderCallbacks).onAdd?.(change.value, change.dynamicIndex ?? change.field);\n\n                        } else if (change.op === OPERATION.DELETE) {\n                            //\n                            // FIXME: `previousValue` should always be avaiiable.\n                            // ADD + DELETE operations are still encoding DELETE operation.\n                            //\n                            if (change.previousValue !== undefined) {\n                                (ref as SchemaDecoderCallbacks).onRemove?.(change.previousValue, change.dynamicIndex ?? change.field);\n                            }\n\n                        } else if (change.op === OPERATION.DELETE_AND_ADD) {\n                            if (change.previousValue !== undefined) {\n                                (ref as SchemaDecoderCallbacks).onRemove?.(change.previousValue, change.dynamicIndex);\n                            }\n                            (ref as SchemaDecoderCallbacks).onAdd?.(change.value, change.dynamicIndex);\n\n                        } else if (\n                            change.op === OPERATION.REPLACE ||\n                            change.value !== change.previousValue\n                        ) {\n                            (ref as SchemaDecoderCallbacks).onChange?.(change.value, change.dynamicIndex);\n                        }\n                    }\n\n                    //\n                    // trigger onRemove on child structure.\n                    //\n                    if (\n                        (change.op & OPERATION.DELETE) === OPERATION.DELETE &&\n                        change.previousValue instanceof Schema &&\n                        change.previousValue.onRemove\n                    ) {\n                        change.previousValue.onRemove();\n                    }\n\n                    if (listener) {\n                        try {\n                            listener.invoke(change.value, change.previousValue);\n                        } catch (e) {\n                            Schema.onError(e);\n                        }\n                    }\n                }\n\n                if (isSchema) {\n                    if (ref.onChange) {\n                        try {\n                            (ref as Schema).onChange(changes);\n                        } catch (e) {\n                            Schema.onError(e);\n                        }\n                    }\n                }\n\n            }\n\n        });\n    }\n}\n"]}},"error":null,"hash":"b33abfde30a328e7987ca75ed49d0493","cacheData":{"env":{}}}