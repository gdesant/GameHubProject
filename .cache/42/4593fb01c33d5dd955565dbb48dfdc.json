{"id":"../../node_modules/@colyseus/schema/lib/annotations.js","dependencies":[{"name":"C:\\Users\\S de Santi\\Desktop\\NewProject\\package.json","includedInParent":true,"mtime":1624620152425},{"name":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\package.json","includedInParent":true,"mtime":1624300837947},{"name":"./Schema","loc":{"line":24,"column":23},"parent":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\annotations.js","resolved":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\Schema.js"},{"name":"./types/ArraySchema","loc":{"line":25,"column":28},"parent":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\annotations.js","resolved":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\types\\ArraySchema.js"},{"name":"./types/MapSchema","loc":{"line":26,"column":26},"parent":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\annotations.js","resolved":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\types\\MapSchema.js"},{"name":"./types","loc":{"line":27,"column":22},"parent":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\annotations.js","resolved":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\@colyseus\\schema\\lib\\types\\index.js"}],"generated":{"js":"\"use strict\";\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spread = (this && this.__spread) || function () {\n    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));\n    return ar;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.defineTypes = exports.deprecated = exports.filterChildren = exports.filter = exports.type = exports.globalContext = exports.Context = exports.hasFilter = exports.SchemaDefinition = void 0;\nvar Schema_1 = require(\"./Schema\");\nvar ArraySchema_1 = require(\"./types/ArraySchema\");\nvar MapSchema_1 = require(\"./types/MapSchema\");\nvar types_1 = require(\"./types\");\nvar SchemaDefinition = /** @class */ (function () {\n    function SchemaDefinition() {\n        //\n        // TODO: use a \"field\" structure combining all these properties per-field.\n        //\n        this.indexes = {};\n        this.fieldsByIndex = {};\n        this.deprecated = {};\n        this.descriptors = {};\n    }\n    SchemaDefinition.create = function (parent) {\n        var definition = new SchemaDefinition();\n        // support inheritance\n        definition.schema = Object.assign({}, parent && parent.schema || {});\n        definition.indexes = Object.assign({}, parent && parent.indexes || {});\n        definition.fieldsByIndex = Object.assign({}, parent && parent.fieldsByIndex || {});\n        definition.descriptors = Object.assign({}, parent && parent.descriptors || {});\n        definition.deprecated = Object.assign({}, parent && parent.deprecated || {});\n        return definition;\n    };\n    SchemaDefinition.prototype.addField = function (field, type) {\n        var index = this.getNextFieldIndex();\n        this.fieldsByIndex[index] = field;\n        this.indexes[field] = index;\n        this.schema[field] = (Array.isArray(type))\n            ? { array: type[0] }\n            : type;\n    };\n    SchemaDefinition.prototype.addFilter = function (field, cb) {\n        if (!this.filters) {\n            this.filters = {};\n            this.indexesWithFilters = [];\n        }\n        this.filters[this.indexes[field]] = cb;\n        this.indexesWithFilters.push(this.indexes[field]);\n        return true;\n    };\n    SchemaDefinition.prototype.addChildrenFilter = function (field, cb) {\n        var index = this.indexes[field];\n        var type = this.schema[field];\n        if (types_1.getType(Object.keys(type)[0])) {\n            if (!this.childFilters) {\n                this.childFilters = {};\n            }\n            this.childFilters[index] = cb;\n            return true;\n        }\n        else {\n            console.warn(\"@filterChildren: field '\" + field + \"' can't have children. Ignoring filter.\");\n        }\n    };\n    SchemaDefinition.prototype.getChildrenFilter = function (field) {\n        return this.childFilters && this.childFilters[this.indexes[field]];\n    };\n    SchemaDefinition.prototype.getNextFieldIndex = function () {\n        return Object.keys(this.schema || {}).length;\n    };\n    return SchemaDefinition;\n}());\nexports.SchemaDefinition = SchemaDefinition;\nfunction hasFilter(klass) {\n    return klass._context && klass._context.useFilters;\n}\nexports.hasFilter = hasFilter;\nvar Context = /** @class */ (function () {\n    function Context() {\n        this.types = {};\n        this.schemas = new Map();\n        this.useFilters = false;\n    }\n    Context.prototype.has = function (schema) {\n        return this.schemas.has(schema);\n    };\n    Context.prototype.get = function (typeid) {\n        return this.types[typeid];\n    };\n    Context.prototype.add = function (schema, typeid) {\n        if (typeid === void 0) { typeid = this.schemas.size; }\n        // FIXME: move this to somewhere else?\n        // support inheritance\n        schema._definition = SchemaDefinition.create(schema._definition);\n        schema._typeid = typeid;\n        this.types[typeid] = schema;\n        this.schemas.set(schema, typeid);\n    };\n    Context.create = function (context) {\n        if (context === void 0) { context = new Context; }\n        return function (definition) {\n            return type(definition, context);\n        };\n    };\n    return Context;\n}());\nexports.Context = Context;\nexports.globalContext = new Context();\n/**\n * `@type()` decorator for proxies\n */\nfunction type(type, context) {\n    if (context === void 0) { context = exports.globalContext; }\n    return function (target, field) {\n        var constructor = target.constructor;\n        constructor._context = context;\n        /*\n         * static schema\n         */\n        if (!context.has(constructor)) {\n            context.add(constructor);\n        }\n        var definition = constructor._definition;\n        definition.addField(field, type);\n        /**\n         * skip if descriptor already exists for this field (`@deprecated()`)\n         */\n        if (definition.descriptors[field]) {\n            return;\n        }\n        var isArray = ArraySchema_1.ArraySchema.is(type);\n        var isMap = !isArray && MapSchema_1.MapSchema.is(type);\n        // TODO: refactor me.\n        // Allow abstract intermediary classes with no fields to be serialized\n        // (See \"should support an inheritance with a Schema type without fields\" test)\n        if (typeof (type) !== \"string\" && !Schema_1.Schema.is(type)) {\n            var childType = Object.values(type)[0];\n            if (typeof (childType) !== \"string\" && !context.has(childType)) {\n                context.add(childType);\n            }\n        }\n        var fieldCached = \"_\" + field;\n        definition.descriptors[fieldCached] = {\n            enumerable: false,\n            configurable: false,\n            writable: true,\n        };\n        definition.descriptors[field] = {\n            get: function () {\n                return this[fieldCached];\n            },\n            set: function (value) {\n                /**\n                 * Create Proxy for array or map items\n                 */\n                // skip if value is the same as cached.\n                if (value === this[fieldCached]) {\n                    return;\n                }\n                if (value !== undefined &&\n                    value !== null) {\n                    // automaticallty transform Array into ArraySchema\n                    if (isArray && !(value instanceof ArraySchema_1.ArraySchema)) {\n                        value = new (ArraySchema_1.ArraySchema.bind.apply(ArraySchema_1.ArraySchema, __spread([void 0], value)))();\n                    }\n                    // automaticallty transform Map into MapSchema\n                    if (isMap && !(value instanceof MapSchema_1.MapSchema)) {\n                        value = new MapSchema_1.MapSchema(value);\n                    }\n                    // try to turn provided structure into a Proxy\n                    if (value['$proxy'] === undefined) {\n                        if (isMap) {\n                            value = MapSchema_1.getMapProxy(value);\n                        }\n                        else if (isArray) {\n                            value = ArraySchema_1.getArrayProxy(value);\n                        }\n                    }\n                    // flag the change for encoding.\n                    this.$changes.change(field);\n                    //\n                    // call setParent() recursively for this and its child\n                    // structures.\n                    //\n                    if (value['$changes']) {\n                        value['$changes'].setParent(this, this.$changes.root, this._definition.indexes[field]);\n                    }\n                }\n                else {\n                    //\n                    // Setting a field to `null` or `undefined` will delete it.\n                    //\n                    this.$changes.delete(field);\n                }\n                this[fieldCached] = value;\n            },\n            enumerable: true,\n            configurable: true\n        };\n    };\n}\nexports.type = type;\n/**\n * `@filter()` decorator for defining data filters per client\n */\nfunction filter(cb) {\n    return function (target, field) {\n        var constructor = target.constructor;\n        var definition = constructor._definition;\n        if (definition.addFilter(field, cb)) {\n            constructor._context.useFilters = true;\n        }\n    };\n}\nexports.filter = filter;\nfunction filterChildren(cb) {\n    return function (target, field) {\n        var constructor = target.constructor;\n        var definition = constructor._definition;\n        if (definition.addChildrenFilter(field, cb)) {\n            constructor._context.useFilters = true;\n        }\n    };\n}\nexports.filterChildren = filterChildren;\n/**\n * `@deprecated()` flag a field as deprecated.\n * The previous `@type()` annotation should remain along with this one.\n */\nfunction deprecated(throws, context) {\n    if (throws === void 0) { throws = true; }\n    if (context === void 0) { context = exports.globalContext; }\n    return function (target, field) {\n        var constructor = target.constructor;\n        var definition = constructor._definition;\n        definition.deprecated[field] = true;\n        if (throws) {\n            definition.descriptors[field] = {\n                get: function () { throw new Error(field + \" is deprecated.\"); },\n                set: function (value) { },\n                enumerable: false,\n                configurable: true\n            };\n        }\n    };\n}\nexports.deprecated = deprecated;\nfunction defineTypes(target, fields, context) {\n    if (context === void 0) { context = target._context || exports.globalContext; }\n    for (var field in fields) {\n        type(fields[field], context)(target.prototype, field);\n    }\n    return target;\n}\nexports.defineTypes = defineTypes;\n"},"sourceMaps":{"js":{"version":3,"file":"annotations.js","sourceRoot":"","sources":["../src/annotations.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AACA,mCAAkC;AAClC,mDAAiE;AACjE,+CAA2D;AAC3D,iCAAkC;AAgDlC;IAAA;QAGI,EAAE;QACF,0EAA0E;QAC1E,EAAE;QAEF,YAAO,GAAgC,EAAE,CAAC;QAC1C,kBAAa,GAAgC,EAAE,CAAC;QAMhD,eAAU,GAAiC,EAAE,CAAC;QAC9C,gBAAW,GAA0C,EAAE,CAAC;IAwD5D,CAAC;IAtDU,uBAAM,GAAb,UAAc,MAAyB;QACnC,IAAM,UAAU,GAAG,IAAI,gBAAgB,EAAE,CAAC;QAE1C,sBAAsB;QACtB,UAAU,CAAC,MAAM,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,IAAI,MAAM,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC;QACrE,UAAU,CAAC,OAAO,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,IAAI,MAAM,CAAC,OAAO,IAAI,EAAE,CAAC,CAAC;QACvE,UAAU,CAAC,aAAa,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,IAAI,MAAM,CAAC,aAAa,IAAI,EAAE,CAAC,CAAC;QACnF,UAAU,CAAC,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,IAAI,MAAM,CAAC,WAAW,IAAI,EAAE,CAAC,CAAC;QAC/E,UAAU,CAAC,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,IAAI,MAAM,CAAC,UAAU,IAAI,EAAE,CAAC,CAAC;QAE7E,OAAO,UAAU,CAAC;IACtB,CAAC;IAED,mCAAQ,GAAR,UAAS,KAAa,EAAE,IAAoB;QACxC,IAAM,KAAK,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;QACvC,IAAI,CAAC,aAAa,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;QAClC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;QAC5B,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;YACtC,CAAC,CAAC,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,EAAE;YACpB,CAAC,CAAC,IAAI,CAAC;IACf,CAAC;IAED,oCAAS,GAAT,UAAU,KAAa,EAAE,EAAkB;QACvC,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE;YACf,IAAI,CAAC,OAAO,GAAG,EAAE,CAAC;YAClB,IAAI,CAAC,kBAAkB,GAAG,EAAE,CAAC;SAChC;QACD,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,GAAG,EAAE,CAAC;QACvC,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;QAClD,OAAO,IAAI,CAAC;IAChB,CAAC;IAED,4CAAiB,GAAjB,UAAkB,KAAa,EAAE,EAA0B;QACvD,IAAM,KAAK,GAAG,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;QAClC,IAAM,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAEhC,IAAI,eAAO,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC,EAAE;YAC/B,IAAI,CAAC,IAAI,CAAC,YAAY,EAAE;gBAAE,IAAI,CAAC,YAAY,GAAG,EAAE,CAAC;aAAE;YAEnD,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,GAAG,EAAE,CAAC;YAC9B,OAAO,IAAI,CAAC;SAEf;aAAM;YACH,OAAO,CAAC,IAAI,CAAC,6BAA2B,KAAK,4CAAyC,CAAC,CAAC;SAC3F;IACL,CAAC;IAED,4CAAiB,GAAjB,UAAkB,KAAa;QAC3B,OAAO,IAAI,CAAC,YAAY,IAAI,IAAI,CAAC,YAAY,CAAC,IAAI,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC;IACvE,CAAC;IAED,4CAAiB,GAAjB;QACI,OAAO,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,IAAI,EAAE,CAAC,CAAC,MAAM,CAAC;IACjD,CAAC;IACL,uBAAC;AAAD,CAAC,AAvED,IAuEC;AAvEY,4CAAgB;AAyE7B,SAAgB,SAAS,CAAC,KAAoB;IAC1C,OAAO,KAAK,CAAC,QAAQ,IAAI,KAAK,CAAC,QAAQ,CAAC,UAAU,CAAC;AACvD,CAAC;AAFD,8BAEC;AAOD;IAAA;QACI,UAAK,GAAkC,EAAE,CAAC;QAC1C,YAAO,GAAG,IAAI,GAAG,EAAyB,CAAC;QAC3C,eAAU,GAAG,KAAK,CAAC;IAyBvB,CAAC;IAvBG,qBAAG,GAAH,UAAI,MAAqB;QACrB,OAAO,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,CAAC;IACpC,CAAC;IAED,qBAAG,GAAH,UAAI,MAAc;QACd,OAAO,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;IAC9B,CAAC;IAED,qBAAG,GAAH,UAAI,MAAqB,EAAE,MAAkC;QAAlC,uBAAA,EAAA,SAAiB,IAAI,CAAC,OAAO,CAAC,IAAI;QACzD,sCAAsC;QACtC,sBAAsB;QACtB,MAAM,CAAC,WAAW,GAAG,gBAAgB,CAAC,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;QAEjE,MAAM,CAAC,OAAO,GAAG,MAAM,CAAC;QACxB,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,GAAG,MAAM,CAAC;QAC5B,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;IACrC,CAAC;IAEM,cAAM,GAAb,UAAc,OAA8B;QAA9B,wBAAA,EAAA,cAAuB,OAAO;QACxC,OAAO,UAAU,UAA0B;YACvC,OAAO,IAAI,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;QACrC,CAAC,CAAA;IACL,CAAC;IACL,cAAC;AAAD,CAAC,AA5BD,IA4BC;AA5BY,0BAAO;AA8BP,QAAA,aAAa,GAAG,IAAI,OAAO,EAAE,CAAC;AAE3C;;GAEG;AACH,SAAgB,IAAI,CAAE,IAAoB,EAAE,OAAgC;IAAhC,wBAAA,EAAA,UAAmB,qBAAa;IACxE,OAAO,UAAU,MAAqB,EAAE,KAAa;QACjD,IAAM,WAAW,GAAG,MAAM,CAAC,WAA4B,CAAC;QACxD,WAAW,CAAC,QAAQ,GAAG,OAAO,CAAC;QAE/B;;WAEG;QACH,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,EAAE;YAC3B,OAAO,CAAC,GAAG,CAAC,WAAW,CAAC,CAAC;SAC5B;QAED,IAAM,UAAU,GAAG,WAAW,CAAC,WAAW,CAAC;QAC3C,UAAU,CAAC,QAAQ,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;QAEjC;;WAEG;QACH,IAAI,UAAU,CAAC,WAAW,CAAC,KAAK,CAAC,EAAE;YAAE,OAAO;SAAE;QAE9C,IAAM,OAAO,GAAG,yBAAW,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;QACrC,IAAM,KAAK,GAAG,CAAC,OAAO,IAAI,qBAAS,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC;QAE7C,qBAAqB;QACrB,sEAAsE;QACtE,+EAA+E;QAC/E,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,QAAQ,IAAI,CAAC,eAAM,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE;YAChD,IAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAAC;YACzC,IAAI,OAAO,CAAC,SAAS,CAAC,KAAK,QAAQ,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;gBAC5D,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;aAC1B;SACJ;QAED,IAAM,WAAW,GAAG,MAAI,KAAO,CAAC;QAEhC,UAAU,CAAC,WAAW,CAAC,WAAW,CAAC,GAAG;YAClC,UAAU,EAAE,KAAK;YACjB,YAAY,EAAE,KAAK;YACnB,QAAQ,EAAE,IAAI;SACjB,CAAC;QAEF,UAAU,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG;YAC5B,GAAG,EAAE;gBACD,OAAO,IAAI,CAAC,WAAW,CAAC,CAAC;YAC7B,CAAC;YAED,GAAG,EAAE,UAAwB,KAAU;gBACnC;;mBAEG;gBAEH,uCAAuC;gBACvC,IAAI,KAAK,KAAK,IAAI,CAAC,WAAW,CAAC,EAAE;oBAC7B,OAAO;iBACV;gBAED,IACI,KAAK,KAAK,SAAS;oBACnB,KAAK,KAAK,IAAI,EAChB;oBACE,kDAAkD;oBAClD,IAAI,OAAO,IAAI,CAAC,CAAC,KAAK,YAAY,yBAAW,CAAC,EAAE;wBAC5C,KAAK,QAAO,yBAAW,YAAX,yBAAW,qBAAI,KAAK,KAAC,CAAC;qBACrC;oBAED,8CAA8C;oBAC9C,IAAI,KAAK,IAAI,CAAC,CAAC,KAAK,YAAY,qBAAS,CAAC,EAAE;wBACxC,KAAK,GAAG,IAAI,qBAAS,CAAC,KAAK,CAAC,CAAC;qBAChC;oBAED,8CAA8C;oBAC9C,IAAI,KAAK,CAAC,QAAQ,CAAC,KAAK,SAAS,EAAE;wBAC/B,IAAI,KAAK,EAAE;4BACP,KAAK,GAAG,uBAAW,CAAC,KAAK,CAAC,CAAC;yBAE9B;6BAAM,IAAI,OAAO,EAAE;4BAChB,KAAK,GAAG,2BAAa,CAAC,KAAK,CAAC,CAAC;yBAChC;qBACJ;oBAED,gCAAgC;oBAChC,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;oBAE5B,EAAE;oBACF,sDAAsD;oBACtD,cAAc;oBACd,EAAE;oBACF,IAAI,KAAK,CAAC,UAAU,CAAC,EAAE;wBAClB,KAAK,CAAC,UAAU,CAAgB,CAAC,SAAS,CACvC,IAAI,EACJ,IAAI,CAAC,QAAQ,CAAC,IAAI,EAClB,IAAI,CAAC,WAAW,CAAC,OAAO,CAAC,KAAK,CAAC,CAClC,CAAC;qBACL;iBAEJ;qBAAM;oBACH,EAAE;oBACF,2DAA2D;oBAC3D,EAAE;oBACF,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;iBAC/B;gBAED,IAAI,CAAC,WAAW,CAAC,GAAG,KAAK,CAAC;YAC9B,CAAC;YAED,UAAU,EAAE,IAAI;YAChB,YAAY,EAAE,IAAI;SACrB,CAAC;IACN,CAAC,CAAA;AACL,CAAC;AA7GD,oBA6GC;AAED;;GAEG;AAEH,SAAgB,MAAM,CAAwC,EAA2B;IACrF,OAAO,UAAU,MAAW,EAAE,KAAa;QACvC,IAAM,WAAW,GAAG,MAAM,CAAC,WAA4B,CAAC;QACxD,IAAM,UAAU,GAAG,WAAW,CAAC,WAAW,CAAC;QAE3C,IAAI,UAAU,CAAC,SAAS,CAAC,KAAK,EAAE,EAAE,CAAC,EAAE;YACjC,WAAW,CAAC,QAAQ,CAAC,UAAU,GAAG,IAAI,CAAC;SAC1C;IACL,CAAC,CAAA;AACL,CAAC;AATD,wBASC;AAED,SAAgB,cAAc,CAA2C,EAAsC;IAC3G,OAAO,UAAU,MAAW,EAAE,KAAa;QACvC,IAAM,WAAW,GAAG,MAAM,CAAC,WAA4B,CAAC;QACxD,IAAM,UAAU,GAAG,WAAW,CAAC,WAAW,CAAC;QAC3C,IAAI,UAAU,CAAC,iBAAiB,CAAC,KAAK,EAAE,EAAE,CAAC,EAAE;YACzC,WAAW,CAAC,QAAQ,CAAC,UAAU,GAAG,IAAI,CAAC;SAC1C;IACL,CAAC,CAAA;AACL,CAAC;AARD,wCAQC;AAGD;;;GAGG;AAEH,SAAgB,UAAU,CAAC,MAAsB,EAAE,OAAgC;IAAxD,uBAAA,EAAA,aAAsB;IAAE,wBAAA,EAAA,UAAmB,qBAAa;IAC/E,OAAO,UAAU,MAAqB,EAAE,KAAa;QACjD,IAAM,WAAW,GAAG,MAAM,CAAC,WAA4B,CAAC;QACxD,IAAM,UAAU,GAAG,WAAW,CAAC,WAAW,CAAC;QAE3C,UAAU,CAAC,UAAU,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC;QAEpC,IAAI,MAAM,EAAE;YACR,UAAU,CAAC,WAAW,CAAC,KAAK,CAAC,GAAG;gBAC5B,GAAG,EAAE,cAAc,MAAM,IAAI,KAAK,CAAI,KAAK,oBAAiB,CAAC,CAAC,CAAC,CAAC;gBAChE,GAAG,EAAE,UAAwB,KAAU,IAAsD,CAAC;gBAC9F,UAAU,EAAE,KAAK;gBACjB,YAAY,EAAE,IAAI;aACrB,CAAC;SACL;IACL,CAAC,CAAA;AACL,CAAC;AAhBD,gCAgBC;AAED,SAAgB,WAAW,CACvB,MAAqB,EACrB,MAA8C,EAC9C,OAAmD;IAAnD,wBAAA,EAAA,UAAmB,MAAM,CAAC,QAAQ,IAAI,qBAAa;IAEnD,KAAK,IAAI,KAAK,IAAI,MAAM,EAAE;QACtB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,EAAE,OAAO,CAAC,CAAC,MAAM,CAAC,SAAS,EAAE,KAAK,CAAC,CAAC;KACzD;IACD,OAAO,MAAM,CAAC;AAClB,CAAC;AATD,kCASC","sourcesContent":["import { ChangeTree } from './changes/ChangeTree';\nimport { Schema } from './Schema';\nimport { ArraySchema, getArrayProxy } from './types/ArraySchema';\nimport { MapSchema, getMapProxy } from './types/MapSchema';\nimport { getType } from './types';\n\n/**\n * Data types\n */\nexport type PrimitiveType =\n    \"string\" |\n    \"number\" |\n    \"boolean\" |\n    \"int8\" |\n    \"uint8\" |\n    \"int16\" |\n    \"uint16\" |\n    \"int32\" |\n    \"uint32\" |\n    \"int64\" |\n    \"uint64\" |\n    \"float32\" |\n    \"float64\" |\n    typeof Schema;\n\nexport type DefinitionType = PrimitiveType\n    | PrimitiveType[]\n    | { array: PrimitiveType }\n    | { map: PrimitiveType }\n    | { collection: PrimitiveType }\n    | { set: PrimitiveType };\n\nexport type Definition = { [field: string]: DefinitionType };\nexport type FilterCallback<\n    T extends Schema = any,\n    V = any,\n    R extends Schema = any\n> = (\n    ((this: T, client: Client, value: V) => boolean) |\n    ((this: T, client: Client, value: V, root: R) => boolean)\n);\n\nexport type FilterChildrenCallback<\n    T extends Schema = any,\n    K = any,\n    V = any,\n    R extends Schema = any\n> = (\n    ((this: T, client: Client, key: K, value: V) => boolean) |\n    ((this: T, client: Client, key: K, value: V, root: R) => boolean)\n)\n\nexport class SchemaDefinition {\n    schema: Definition;\n\n    //\n    // TODO: use a \"field\" structure combining all these properties per-field.\n    //\n\n    indexes: { [field: string]: number } = {};\n    fieldsByIndex: { [index: number]: string } = {};\n\n    filters: { [field: string]: FilterCallback };\n    indexesWithFilters: number[];\n    childFilters: { [field: string]: FilterChildrenCallback }; // childFilters are used on Map, Array, Set items.\n\n    deprecated: { [field: string]: boolean } = {};\n    descriptors: PropertyDescriptorMap & ThisType<any> = {};\n\n    static create(parent?: SchemaDefinition) {\n        const definition = new SchemaDefinition();\n\n        // support inheritance\n        definition.schema = Object.assign({}, parent && parent.schema || {});\n        definition.indexes = Object.assign({}, parent && parent.indexes || {});\n        definition.fieldsByIndex = Object.assign({}, parent && parent.fieldsByIndex || {});\n        definition.descriptors = Object.assign({}, parent && parent.descriptors || {});\n        definition.deprecated = Object.assign({}, parent && parent.deprecated || {});\n\n        return definition;\n    }\n\n    addField(field: string, type: DefinitionType) {\n        const index = this.getNextFieldIndex();\n        this.fieldsByIndex[index] = field;\n        this.indexes[field] = index;\n        this.schema[field] = (Array.isArray(type))\n            ? { array: type[0] }\n            : type;\n    }\n\n    addFilter(field: string, cb: FilterCallback) {\n        if (!this.filters) {\n            this.filters = {};\n            this.indexesWithFilters = [];\n        }\n        this.filters[this.indexes[field]] = cb;\n        this.indexesWithFilters.push(this.indexes[field]);\n        return true;\n    }\n\n    addChildrenFilter(field: string, cb: FilterChildrenCallback) {\n        const index = this.indexes[field];\n        const type = this.schema[field];\n\n        if (getType(Object.keys(type)[0])) {\n            if (!this.childFilters) { this.childFilters = {}; }\n\n            this.childFilters[index] = cb;\n            return true;\n\n        } else {\n            console.warn(`@filterChildren: field '${field}' can't have children. Ignoring filter.`);\n        }\n    }\n\n    getChildrenFilter(field: string) {\n        return this.childFilters && this.childFilters[this.indexes[field]];\n    }\n\n    getNextFieldIndex() {\n        return Object.keys(this.schema || {}).length;\n    }\n}\n\nexport function hasFilter(klass: typeof Schema) {\n    return klass._context && klass._context.useFilters;\n}\n\n// Colyseus integration\nexport type Client = {\n    sessionId: string,\n} & any;\n\nexport class Context {\n    types: {[id: number]: typeof Schema} = {};\n    schemas = new Map<typeof Schema, number>();\n    useFilters = false;\n\n    has(schema: typeof Schema) {\n        return this.schemas.has(schema);\n    }\n\n    get(typeid: number) {\n        return this.types[typeid];\n    }\n\n    add(schema: typeof Schema, typeid: number = this.schemas.size) {\n        // FIXME: move this to somewhere else?\n        // support inheritance\n        schema._definition = SchemaDefinition.create(schema._definition);\n\n        schema._typeid = typeid;\n        this.types[typeid] = schema;\n        this.schemas.set(schema, typeid);\n    }\n\n    static create(context: Context = new Context) {\n        return function (definition: DefinitionType) {\n            return type(definition, context);\n        }\n    }\n}\n\nexport const globalContext = new Context();\n\n/**\n * `@type()` decorator for proxies\n */\nexport function type (type: DefinitionType, context: Context = globalContext): PropertyDecorator {\n    return function (target: typeof Schema, field: string) {\n        const constructor = target.constructor as typeof Schema;\n        constructor._context = context;\n\n        /*\n         * static schema\n         */\n        if (!context.has(constructor)) {\n            context.add(constructor);\n        }\n\n        const definition = constructor._definition;\n        definition.addField(field, type);\n\n        /**\n         * skip if descriptor already exists for this field (`@deprecated()`)\n         */\n        if (definition.descriptors[field]) { return; }\n\n        const isArray = ArraySchema.is(type);\n        const isMap = !isArray && MapSchema.is(type);\n\n        // TODO: refactor me.\n        // Allow abstract intermediary classes with no fields to be serialized\n        // (See \"should support an inheritance with a Schema type without fields\" test)\n        if (typeof (type) !== \"string\" && !Schema.is(type)) {\n            const childType = Object.values(type)[0];\n            if (typeof (childType) !== \"string\" && !context.has(childType)) {\n                context.add(childType);\n            }\n        }\n\n        const fieldCached = `_${field}`;\n\n        definition.descriptors[fieldCached] = {\n            enumerable: false,\n            configurable: false,\n            writable: true,\n        };\n\n        definition.descriptors[field] = {\n            get: function () {\n                return this[fieldCached];\n            },\n\n            set: function (this: Schema, value: any) {\n                /**\n                 * Create Proxy for array or map items\n                 */\n\n                // skip if value is the same as cached.\n                if (value === this[fieldCached]) {\n                    return;\n                }\n\n                if (\n                    value !== undefined &&\n                    value !== null\n                ) {\n                    // automaticallty transform Array into ArraySchema\n                    if (isArray && !(value instanceof ArraySchema)) {\n                        value = new ArraySchema(...value);\n                    }\n\n                    // automaticallty transform Map into MapSchema\n                    if (isMap && !(value instanceof MapSchema)) {\n                        value = new MapSchema(value);\n                    }\n\n                    // try to turn provided structure into a Proxy\n                    if (value['$proxy'] === undefined) {\n                        if (isMap) {\n                            value = getMapProxy(value);\n\n                        } else if (isArray) {\n                            value = getArrayProxy(value);\n                        }\n                    }\n\n                    // flag the change for encoding.\n                    this.$changes.change(field);\n\n                    //\n                    // call setParent() recursively for this and its child\n                    // structures.\n                    //\n                    if (value['$changes']) {\n                        (value['$changes'] as ChangeTree).setParent(\n                            this,\n                            this.$changes.root,\n                            this._definition.indexes[field],\n                        );\n                    }\n\n                } else {\n                    //\n                    // Setting a field to `null` or `undefined` will delete it.\n                    //\n                    this.$changes.delete(field);\n                }\n\n                this[fieldCached] = value;\n            },\n\n            enumerable: true,\n            configurable: true\n        };\n    }\n}\n\n/**\n * `@filter()` decorator for defining data filters per client\n */\n\nexport function filter<T extends Schema, V, R extends Schema>(cb: FilterCallback<T, V, R>): PropertyDecorator {\n    return function (target: any, field: string) {\n        const constructor = target.constructor as typeof Schema;\n        const definition = constructor._definition;\n\n        if (definition.addFilter(field, cb)) {\n            constructor._context.useFilters = true;\n        }\n    }\n}\n\nexport function filterChildren<T extends Schema, K, V, R extends Schema>(cb: FilterChildrenCallback<T, K, V, R>): PropertyDecorator {\n    return function (target: any, field: string) {\n        const constructor = target.constructor as typeof Schema;\n        const definition = constructor._definition;\n        if (definition.addChildrenFilter(field, cb)) {\n            constructor._context.useFilters = true;\n        }\n    }\n}\n\n\n/**\n * `@deprecated()` flag a field as deprecated.\n * The previous `@type()` annotation should remain along with this one.\n */\n\nexport function deprecated(throws: boolean = true, context: Context = globalContext): PropertyDecorator {\n    return function (target: typeof Schema, field: string) {\n        const constructor = target.constructor as typeof Schema;\n        const definition = constructor._definition;\n\n        definition.deprecated[field] = true;\n\n        if (throws) {\n            definition.descriptors[field] = {\n                get: function () { throw new Error(`${field} is deprecated.`); },\n                set: function (this: Schema, value: any) { /* throw new Error(`${field} is deprecated.`); */ },\n                enumerable: false,\n                configurable: true\n            };\n        }\n    }\n}\n\nexport function defineTypes(\n    target: typeof Schema,\n    fields: { [property: string]: DefinitionType },\n    context: Context = target._context || globalContext\n) {\n    for (let field in fields) {\n        type(fields[field], context)(target.prototype, field);\n    }\n    return target;\n}\n"]}},"error":null,"hash":"506de9f9ec2d73f047744b9e5983048d","cacheData":{"env":{}}}