{"id":"jyAE","dependencies":[{"name":"C:\\Users\\S de Santi\\Desktop\\NewProject\\package.json","includedInParent":true,"mtime":1624620152425},{"name":"C:\\Users\\S de Santi\\Desktop\\NewProject\\node_modules\\colyseus.js\\package.json","includedInParent":true,"mtime":1624300838072}],"generated":{"js":"\"use strict\";\n/**\n * Copyright (c) 2014 Ion Drive Software Ltd.\n * https://github.com/darrachequesne/notepack/\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction utf8Write(view, offset, str) {\n  var c = 0;\n\n  for (var i = 0, l = str.length; i < l; i++) {\n    c = str.charCodeAt(i);\n\n    if (c < 0x80) {\n      view.setUint8(offset++, c);\n    } else if (c < 0x800) {\n      view.setUint8(offset++, 0xc0 | c >> 6);\n      view.setUint8(offset++, 0x80 | c & 0x3f);\n    } else if (c < 0xd800 || c >= 0xe000) {\n      view.setUint8(offset++, 0xe0 | c >> 12);\n      view.setUint8(offset++, 0x80 | c >> 6 & 0x3f);\n      view.setUint8(offset++, 0x80 | c & 0x3f);\n    } else {\n      i++;\n      c = 0x10000 + ((c & 0x3ff) << 10 | str.charCodeAt(i) & 0x3ff);\n      view.setUint8(offset++, 0xf0 | c >> 18);\n      view.setUint8(offset++, 0x80 | c >> 12 & 0x3f);\n      view.setUint8(offset++, 0x80 | c >> 6 & 0x3f);\n      view.setUint8(offset++, 0x80 | c & 0x3f);\n    }\n  }\n}\n\nfunction utf8Length(str) {\n  var c = 0,\n      length = 0;\n\n  for (var i = 0, l = str.length; i < l; i++) {\n    c = str.charCodeAt(i);\n\n    if (c < 0x80) {\n      length += 1;\n    } else if (c < 0x800) {\n      length += 2;\n    } else if (c < 0xd800 || c >= 0xe000) {\n      length += 3;\n    } else {\n      i++;\n      length += 4;\n    }\n  }\n\n  return length;\n}\n\nfunction _encode(bytes, defers, value) {\n  var type = _typeof(value),\n      i = 0,\n      l = 0,\n      hi = 0,\n      lo = 0,\n      length = 0,\n      size = 0;\n\n  if (type === 'string') {\n    length = utf8Length(value); // fixstr\n\n    if (length < 0x20) {\n      bytes.push(length | 0xa0);\n      size = 1;\n    } // str 8\n    else if (length < 0x100) {\n        bytes.push(0xd9, length);\n        size = 2;\n      } // str 16\n      else if (length < 0x10000) {\n          bytes.push(0xda, length >> 8, length);\n          size = 3;\n        } // str 32\n        else if (length < 0x100000000) {\n            bytes.push(0xdb, length >> 24, length >> 16, length >> 8, length);\n            size = 5;\n          } else {\n            throw new Error('String too long');\n          }\n\n    defers.push({\n      _str: value,\n      _length: length,\n      _offset: bytes.length\n    });\n    return size + length;\n  }\n\n  if (type === 'number') {\n    // TODO: encode to float 32?\n    // float 64\n    if (Math.floor(value) !== value || !isFinite(value)) {\n      bytes.push(0xcb);\n      defers.push({\n        _float: value,\n        _length: 8,\n        _offset: bytes.length\n      });\n      return 9;\n    }\n\n    if (value >= 0) {\n      // positive fixnum\n      if (value < 0x80) {\n        bytes.push(value);\n        return 1;\n      } // uint 8\n\n\n      if (value < 0x100) {\n        bytes.push(0xcc, value);\n        return 2;\n      } // uint 16\n\n\n      if (value < 0x10000) {\n        bytes.push(0xcd, value >> 8, value);\n        return 3;\n      } // uint 32\n\n\n      if (value < 0x100000000) {\n        bytes.push(0xce, value >> 24, value >> 16, value >> 8, value);\n        return 5;\n      } // uint 64\n\n\n      hi = value / Math.pow(2, 32) >> 0;\n      lo = value >>> 0;\n      bytes.push(0xcf, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n      return 9;\n    } else {\n      // negative fixnum\n      if (value >= -0x20) {\n        bytes.push(value);\n        return 1;\n      } // int 8\n\n\n      if (value >= -0x80) {\n        bytes.push(0xd0, value);\n        return 2;\n      } // int 16\n\n\n      if (value >= -0x8000) {\n        bytes.push(0xd1, value >> 8, value);\n        return 3;\n      } // int 32\n\n\n      if (value >= -0x80000000) {\n        bytes.push(0xd2, value >> 24, value >> 16, value >> 8, value);\n        return 5;\n      } // int 64\n\n\n      hi = Math.floor(value / Math.pow(2, 32));\n      lo = value >>> 0;\n      bytes.push(0xd3, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n      return 9;\n    }\n  }\n\n  if (type === 'object') {\n    // nil\n    if (value === null) {\n      bytes.push(0xc0);\n      return 1;\n    }\n\n    if (Array.isArray(value)) {\n      length = value.length; // fixarray\n\n      if (length < 0x10) {\n        bytes.push(length | 0x90);\n        size = 1;\n      } // array 16\n      else if (length < 0x10000) {\n          bytes.push(0xdc, length >> 8, length);\n          size = 3;\n        } // array 32\n        else if (length < 0x100000000) {\n            bytes.push(0xdd, length >> 24, length >> 16, length >> 8, length);\n            size = 5;\n          } else {\n            throw new Error('Array too large');\n          }\n\n      for (i = 0; i < length; i++) {\n        size += _encode(bytes, defers, value[i]);\n      }\n\n      return size;\n    } // fixext 8 / Date\n\n\n    if (value instanceof Date) {\n      var time = value.getTime();\n      hi = Math.floor(time / Math.pow(2, 32));\n      lo = time >>> 0;\n      bytes.push(0xd7, 0, hi >> 24, hi >> 16, hi >> 8, hi, lo >> 24, lo >> 16, lo >> 8, lo);\n      return 10;\n    }\n\n    if (value instanceof ArrayBuffer) {\n      length = value.byteLength; // bin 8\n\n      if (length < 0x100) {\n        bytes.push(0xc4, length);\n        size = 2;\n      } else // bin 16\n        if (length < 0x10000) {\n          bytes.push(0xc5, length >> 8, length);\n          size = 3;\n        } else // bin 32\n          if (length < 0x100000000) {\n            bytes.push(0xc6, length >> 24, length >> 16, length >> 8, length);\n            size = 5;\n          } else {\n            throw new Error('Buffer too large');\n          }\n\n      defers.push({\n        _bin: value,\n        _length: length,\n        _offset: bytes.length\n      });\n      return size + length;\n    }\n\n    if (typeof value.toJSON === 'function') {\n      return _encode(bytes, defers, value.toJSON());\n    }\n\n    var keys = [],\n        key = '';\n    var allKeys = Object.keys(value);\n\n    for (i = 0, l = allKeys.length; i < l; i++) {\n      key = allKeys[i];\n\n      if (typeof value[key] !== 'function') {\n        keys.push(key);\n      }\n    }\n\n    length = keys.length; // fixmap\n\n    if (length < 0x10) {\n      bytes.push(length | 0x80);\n      size = 1;\n    } // map 16\n    else if (length < 0x10000) {\n        bytes.push(0xde, length >> 8, length);\n        size = 3;\n      } // map 32\n      else if (length < 0x100000000) {\n          bytes.push(0xdf, length >> 24, length >> 16, length >> 8, length);\n          size = 5;\n        } else {\n          throw new Error('Object too large');\n        }\n\n    for (i = 0; i < length; i++) {\n      key = keys[i];\n      size += _encode(bytes, defers, key);\n      size += _encode(bytes, defers, value[key]);\n    }\n\n    return size;\n  } // false/true\n\n\n  if (type === 'boolean') {\n    bytes.push(value ? 0xc3 : 0xc2);\n    return 1;\n  } // fixext 1 / undefined\n\n\n  if (type === 'undefined') {\n    bytes.push(0xd4, 0, 0);\n    return 3;\n  }\n\n  throw new Error('Could not encode');\n}\n\nfunction encode(value) {\n  var bytes = [];\n  var defers = [];\n\n  var size = _encode(bytes, defers, value);\n\n  var buf = new ArrayBuffer(size);\n  var view = new DataView(buf);\n  var deferIndex = 0;\n  var deferWritten = 0;\n  var nextOffset = -1;\n\n  if (defers.length > 0) {\n    nextOffset = defers[0]._offset;\n  }\n\n  var defer,\n      deferLength = 0,\n      offset = 0;\n\n  for (var i = 0, l = bytes.length; i < l; i++) {\n    view.setUint8(deferWritten + i, bytes[i]);\n\n    if (i + 1 !== nextOffset) {\n      continue;\n    }\n\n    defer = defers[deferIndex];\n    deferLength = defer._length;\n    offset = deferWritten + nextOffset;\n\n    if (defer._bin) {\n      var bin = new Uint8Array(defer._bin);\n\n      for (var j = 0; j < deferLength; j++) {\n        view.setUint8(offset + j, bin[j]);\n      }\n    } else if (defer._str) {\n      utf8Write(view, offset, defer._str);\n    } else if (defer._float !== undefined) {\n      view.setFloat64(offset, defer._float);\n    }\n\n    deferIndex++;\n    deferWritten += deferLength;\n\n    if (defers[deferIndex]) {\n      nextOffset = defers[deferIndex]._offset;\n    }\n  }\n\n  return buf;\n}\n\nexports.default = encode;"},"sourceMaps":null,"error":null,"hash":"ff7c7f16080b30f34ce50b09ab20a62d","cacheData":{"env":{}}}