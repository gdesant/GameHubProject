"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;var t=function(t,n){return t(n={exports:{}},n.exports),n.exports}((function(t,n){
/*! axis.js v1.2.1 | (c) 2016 @toddmotto | https://github.com/toddmotto/axis */
t.exports=function(){var t={},n="Array Object String Date RegExp Function Boolean Number Null Undefined".split(" ");function r(){return Object.prototype.toString.call(this).slice(8,-1)}for(var e=n.length;e--;)t["is"+n[e]]=function(t){return function(n){return r.call(n)===t}}(n[e]);return t}()})),n=t.isObject,r=t.isNumber,e=t.isArray,i=t.isString;function s(t,n){return n+t*(1&n)>>1}function o(t,n){return(t%n+n)%n}function u(t,n){if(!/^(N|S)?(E|W)?$/i.test(t))throw new Error(`Invalid compass direction: ${t}. Choose from E, SE, S, SW, W, NW, N or NE.`);if(n=n.toLowerCase(),t=t.toUpperCase(),"pointy"===n&&["N","S"].includes(t))throw new Error(`Direction ${t} is ambiguous for pointy hexes. Did you mean ${t}E or ${t}W?`);if("flat"===n&&["E","W"].includes(t))throw new Error(`Direction ${t} is ambiguous for flat hexes. Did you mean N${t} or S${t}?`);return{pointy:{E:0,SE:1,SW:2,W:3,NW:4,NE:5},flat:{SE:0,S:1,SW:2,NW:3,N:4,NE:5}}[n][t]}function c(t,n){return r(t)||r(n)?r(t)?r(n)||(n=t):t=n:t=n=0,{x:t,y:n}}const a=[{q:1,r:0,s:-1},{q:0,r:1,s:-1},{q:-1,r:1,s:0},{q:-1,r:0,s:1},{q:0,r:-1,s:1},{q:1,r:-1,s:0}],h=[{q:2,r:-1,s:-1},{q:1,r:1,s:-2},{q:-1,r:2,s:-1},{q:-2,r:1,s:1},{q:-1,r:-1,s:2},{q:1,r:-2,s:1}],f={q:1e-6,r:1e-6,s:-2e-6};function l(t){return r(t)?this[t]:this[this.indexOf(t)]}function d({isValidHex:t}){return function(n,e){if(!t(e))return this;const i=r(n)?n:this.indexOf(n);return i<0?this.push(e):this[i]=e,this}}function x(t,n){const r=t.distance(n),e=1/Math.max(r,1);let i=[];for(let s=0;s<=r;s++){const r=t.nudge().lerp(n.nudge(),e*s).round();i.push(this.get(r))}return i}function y({isValidHex:t}){return function(n,r=0,e=!0){if(!t(n))throw new Error(`Invalid center hex: ${n}.`);if(!this.get(n))throw new Error(`Center hex with coordinates ${n} not present in grid.`);let i=[];for(let t=-r;t<=r;t++)for(let s=Math.max(-r,-t-r);s<=Math.min(r,-t+r);s++){const r=this.get(n.cubeToCartesian({q:n.q+t,r:n.r+s}));n.equals(r)&&!e||i.push(r)}return i.filter(Boolean)}}function p({isValidHex:t,signedModulo:n,compassToNumberDirection:r}){return function(e,s="all",o=!1){if(!t(e))throw new Error(`Invalid hex: ${e}.`);const u=o?h:a;return"all"===s&&(s=[0,1,2,3,4,5]),[].concat(s).map(t=>{i(t)&&(t=r(t,e.orientation)),(t<0||t>5)&&(t=n(t,6));const{q:s,r:o}=u[t];return this.get(e.cubeToCartesian({q:e.q+s,r:e.r+o}))})}}function g(){if(0===this.length)return 0;const{0:t,length:n,[n-1]:r}=this[0].isPointy()?[...this].sort((t,n)=>n.s-t.s||t.q-n.q):[...this].sort((t,n)=>t.q-n.q);return r.toPoint().x-t.toPoint().x+this[0].width()}function b(){if(0===this.length)return 0;const{0:t,length:n,[n-1]:r}=this[0].isPointy()?[...this].sort((t,n)=>t.r-n.r):[...this].sort((t,n)=>n.s-t.s||t.r-n.r);return r.toPoint().y-t.toPoint().y+this[0].height()}function q({Hex:t}){return function(n,r){return t().fromPoint(n,r)}}function P({Grid:t,Hex:n}){return function({width:r,height:e,start:i,direction:s=1,onCreate:o=(()=>{})}){i=n(i);const[u,c,a]={1:["q","r","s"],3:["r","s","q"],5:["s","q","r"]}[s],h=new t;h.width=r,h.height=e,h.start=i,h.direction=s;for(let t=0;t<r;t++)for(let r=0;r<e;r++){const e=n({[u]:t+i[u],[c]:r+i[c],[a]:-t-r+i[a]});o(e,h),h.push(e)}return h}}function w({Grid:t,Hex:n}){return function({size:r,start:e,direction:i=1,onCreate:s=(()=>{})}){e=n(e);const o={1:{rStart:()=>0,rEnd:t=>r-t},5:{rStart:t=>r-t,rEnd:()=>r+1}},{rStart:u,rEnd:c}=o[i],a=new t;a.size=r,a.start=e,a.direction=i;for(let t=0;t<r;t++)for(let r=u(t);r<c(t);r++){const i=n({q:t+e.q,r:r+e.r,s:-t-r+e.s});s(i,a),a.push(i)}return a}}function m({Grid:t,Hex:n}){return function({radius:r,center:e,onCreate:i=(()=>{})}){e=n(e);const s=new t;s.radius=r,s.center=e;for(let t=-r;t<=r;t++){const o=Math.max(-r,-t-r),u=Math.min(r,-t+r);for(let r=o;r<=u;r++){const o=n({q:t+e.q,r:r+e.r,s:-t-r+e.s});i(o,s),s.push(o)}}return s}}function H({Grid:t,Hex:n,compassToNumberDirection:r,signedModulo:e}){return function({width:o,height:u,start:c,direction:a=(n().isPointy()?0:1),onCreate:h=(()=>{})}){c=n(c),i(a)&&(a=r(a,c.orientation)),(a<0||a>5)&&(a=e(a,6));const[f,l,d]=[["q","r","s"],["r","q","s"],["r","s","q"],["s","r","q"],["s","q","r"],["q","s","r"]][a],[x,y]=c.isPointy()?[o,u]:[u,o],p=new t;p.width=o,p.height=u,p.start=c,p.direction=a;for(let t=0;t<y;t++){const r=s(c.offset,t);for(let e=-r;e<x-r;e++){const r=n({[f]:e+c[f],[l]:t+c[l],[d]:-e-t+c[d]});h(r,p),p.push(r)}}return p}}function O({Grid:t,Hex:n}){return function({radius:r,center:e,onCreate:i=(()=>{})}){e=n(e);const s=new t;s.radius=r,s.center=e;const{q:o,r:u,s:c}=e;let h=n({q:o,r:u-r,s:c+r});for(let t=0;t<6;t++)for(let e=0;e<r;e++){i(h,s),s.push(h);const{q:r,r:e,s:o}=a[t];h=n({q:h.q+r,r:h.r+e,s:h.s+o})}return s}}function j({Grid:t,Hex:n}){return function({radius:r,center:e,onCreate:i=(()=>{})}){e=n(e);let s=new t;i(e,s),s.push(e);for(let t=1;t<=r;t++)s=s.concat(this.ring({radius:t,center:e,onCreate:i}));return s.radius=r,s.center=e,s}}function M({Point:t}){return function(n,r){let e;return({x:e,y:r}=t(n,r)),t(this.x+e,this.y+r)}}function E({Point:t}){return function(n,r){let e;return({x:e,y:r}=t(n,r)),t(this.x-e,this.y-r)}}function C({Point:t}){return function(n,r){let e;return({x:e,y:r}=t(n,r)),t(this.x*e,this.y*r)}}function N({Point:t}){return function(n,r){let e;return({x:e,y:r}=t(n,r)),t(this.x/e,this.y/r)}}function S({ensureXY:t}){const i={add:M({Point:s}),subtract:E({Point:s}),multiply:C({Point:s}),divide:N({Point:s})};function s(s,o){let u;return u=r(s)?t(s,o):e(s)?t(...s):n(s)?t(s.x,s.y):t(0),Object.assign(Object.create(i),u)}return s}const R=S({ensureXY:c});class $ extends Array{static isValidHex(t){return!0===(t||{}).__isHoneycombHex}fill(){throw new TypeError("Grid.prototype.fill is not implemented")}includes(t,n=0){return!!(this.indexOf(t,n)+1)}indexOf(t,n=0){const{length:r}=this;let e=Number(n);for(t=R(t),e=Math.max(e>=0?e:r+e,0);e<r;e++)if(this[e].equals(t))return e;return-1}lastIndexOf(t,n=this.length-1){const{length:r}=this;let e=Number(n);for(t=R(t),e=e>=0?Math.min(e,r-1):r+e;e>=0;e--)if(this[e].equals(t))return e;return-1}push(...t){return super.push(...t.filter($.isValidHex))}splice(t,n,...r){return null==n?super.splice(t):super.splice(t,n,...r.filter($.isValidHex))}unshift(...t){return super.unshift(...t.filter($.isValidHex))}}function v(t,n,r){return n in t?Object.defineProperty(t,n,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[n]=r,t}function T(t,n){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var e=Object.getOwnPropertySymbols(t);n&&(e=e.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),r.push.apply(r,e)}return r}function G(t){for(var n=1;n<arguments.length;n++){var r=null!=arguments[n]?arguments[n]:{};n%2?T(Object(r),!0).forEach((function(n){v(t,n,r[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):T(Object(r)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(r,n))}))}return t}function D(t,n){if(null==t)return{};var r,e,i=function(t,n){if(null==t)return{};var r,e,i={},s=Object.keys(t);for(e=0;e<s.length;e++)r=s[e],n.indexOf(r)>=0||(i[r]=t[r]);return i}(t,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(t);for(e=0;e<s.length;e++)r=s[e],n.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(t,r)&&(i[r]=t[r])}return i}function z({Hex:t}){return function(...n){return Object.assign(this,t(...n))}}function V(){return{x:this.x,y:this.y}}function W(){return{q:this.q,r:this.r,s:this.s}}function I({q:t,r:n}){let r,e;return this.isPointy()?(r=t+s(this.offset,n),e=n):(r=t,e=n+s(this.offset,t)),{x:r,y:e}}function X(){return"pointy"===this.orientation.toLowerCase()}function Y(){return"flat"===this.orientation.toLowerCase()}function B(){const{xRadius:t}=this.size;return this.isPointy()?t*Math.sqrt(3):2*t}function _(){const{yRadius:t}=this.size;return this.isPointy()?2*t:t*Math.sqrt(3)}function A({Point:t}){return function(){const n=this.width(),r=this.height(),{x:e,y:i}=this.origin;return this.isPointy()?[t(n-e,.25*r-i),t(n-e,.75*r-i),t(.5*n-e,r-i),t(0-e,.75*r-i),t(0-e,.25*r-i),t(.5*n-e,0-i)]:[t(n-e,.5*r-i),t(.75*n-e,r-i),t(.25*n-e,r-i),t(0-e,.5*r-i),t(.25*n-e,0-i),t(.75*n-e,0-i)]}}function L({Point:t}){return function(){const{x:n,y:r}=this.origin;return t(this.width()/2-n,this.height()/2-r)}}function k({Point:t}){return function(){const{q:n,r:r,size:e}=this,{xRadius:i,yRadius:s}=e;let o,u;return this.isPointy()?(o=i*Math.sqrt(3)*(n+r/2),u=3*s/2*r):(o=3*i/2*n,u=s*Math.sqrt(3)*(r+n/2)),t(o,u)}}function F({Point:t,Hex:n}){return function(r,e){const{xRadius:i,yRadius:s}=this.size;let o,u,c;return({x:o,y:e}=t(r,e).subtract(this.center())),this.isPointy()?(u=Math.sqrt(3)*o/(3*i)-e/(3*s),c=2/3*(e/s)):(u=2/3*(o/i),c=Math.sqrt(3)*e/(3*s)-o/(3*i)),n({q:u,r:c,s:-u-c}).round()}}function U({Hex:t,Point:n}){return function(r){const{x:e,y:i}=n(r);return t(this.x+e,this.y+i,G({},this))}}function J({Hex:t,Point:n}){return function(r){const{x:e,y:i}=n(r);return t(this.x-e,this.y-i,G({},this))}}function K({Point:t}){return function(n){if(null!=n&&(e(n)||r(n.x)&&r(n.y))){const{x:r,y:e}=t(n);return this.x===r&&this.y===e}return!1}}function Q(t){return Math.max(Math.abs(this.q-t.q),Math.abs(this.r-t.r),Math.abs(this.s-t.s))}function Z({Hex:t}){return function(){let{q:n,r:r,s:e}=this,i=Math.round(n),s=Math.round(r),o=Math.round(e);const u=Math.abs(n-i),c=Math.abs(r-s),a=Math.abs(e-o);return u>c&&u>a?i=-s-o:c>a?s=-i-o:o=-i-s,t(G(G({},this),{},{q:i,r:s,s:o}))}}function tt({Hex:t}){return function(n,r){const e=this.q*(1-r)+n.q*r,i=this.r*(1-r)+n.r*r;return t(G(G({},this),{},{q:e,r:i,s:-e-i}))}}function nt({Hex:t}){return function(){const{q:n,r:r,s:e}=f;return t(G(G({},this),{},{q:this.q+n,r:this.r+r,s:this.s+e}))}}function rt(){return`${this.x},${this.y}`}const et={thirdCoordinate:function(t,n){return-t-n}};const it=S({ensureXY:c}),st=function({ensureXY:t,normalizeRadiuses:i,Point:o}){return function(u={}){const c=function({Point:t}){return function(n,r){let e,i,o;return({x:e,y:r}=t(n,r)),this.isPointy()?(i=e-s(this.offset,r),o=r):(i=e,o=r-s(this.offset,e)),{q:i,r:o,s:-i-o}}}({Point:o}),a={__isHoneycombHex:!0,orientation:"pointy",origin:0,size:{xRadius:1,yRadius:1},offset:-1,get q(){return this.cartesianToCube(this).q},get r(){return this.cartesianToCube(this).r},get s(){return this.cartesianToCube(this).s},add:U({Hex:f,Point:o}),cartesian:V,cartesianToCube:c,center:L({Point:o}),coordinates:V,corners:A({Point:o}),cube:W,cubeToCartesian:I,distance:Q,equals:K({Point:o}),fromPoint:F({Point:o,Hex:f}),height:_,isFlat:Y,isPointy:X,lerp:tt({Hex:f}),nudge:nt({Hex:f}),round:Z({Hex:f}),set:z({Hex:f}),subtract:J({Hex:f,Point:o}),toCartesian:I,toCube:c,toPoint:k({Point:o}),toString:rt,width:B},h=Object.assign(a,u);function f(i,s,o={}){let u;if(n(i)){let{q:t,r:n,s:e}=i,c=D(i,["q","r","s"]);if(r(t)||r(n)||r(e)){const r=t+n+e;if(Number.isNaN(r)||r>1e-12)throw new Error(`Cube coordinates must have a sum of 0. q: ${t}, r: ${n}, s: ${e}, sum: ${t+n+e}.`);({x:u,y:s}=h.cubeToCartesian({q:t,r:n,s:e}))}else({x:u,y:s}=i);o=c}else e(i)?([u,s]=i,o={}):u=i;return Object.assign(Object.create(h),Object.assign(o,t(u,s)))}return h.size=i(h.size,h.isPointy()),h.origin=o(h.origin),Object.assign(f,et,{toJSON:()=>u}),f}}({ensureXY:c,normalizeRadiuses:function(t,e){if(n(t)){if(r(t.xRadius)&&r(t.yRadius))return t;const{width:n,height:i}=t;if(r(n)&&r(i))return e?{xRadius:n/Math.sqrt(3),yRadius:i/2}:{xRadius:n/2,yRadius:i/Math.sqrt(3)}}if(r(t))return{xRadius:t,yRadius:t};throw new Error(`Invalid size: ${t}. Set it as a number or as an object containing width and height.`)},Point:it}),ot=function({extendHex:t,Grid:n,Point:i}){const{isValidHex:s}=n;return function(c=t()){function a(...t){return t=t.filter(Boolean),e(t[0])&&(0===t[0].length||t[0].some(t=>!r(t)))&&(t=t[0]),new n(...t.map(t=>c(t)))}return Object.assign(a,{Hex:c,isValidHex:s,pointToHex:q({Point:i,Hex:c}),parallelogram:P({Grid:n,Hex:c}),triangle:w({Grid:n,Hex:c}),hexagon:m({Grid:n,Hex:c}),rectangle:H({Grid:n,Hex:c,compassToNumberDirection:u,signedModulo:o}),ring:O({Grid:n,Hex:c}),spiral:j({Grid:n,Hex:c})}),Object.assign(n.prototype,{get:l,hexesBetween:x,hexesInRange:y({isValidHex:s}),neighborsOf:p({isValidHex:s,signedModulo:o,compassToNumberDirection:u}),pointHeight:b,pointWidth:g,set:d({isValidHex:s})}),a}}({extendHex:st,Grid:$,Point:it});export{it as Point,ot as defineGrid,st as extendHex};
//# sourceMappingURL=honeycomb.esm.min.js.map
